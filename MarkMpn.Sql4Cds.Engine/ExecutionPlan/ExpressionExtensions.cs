using System;
using System.Collections.Generic;
using System.Data.SqlTypes;
using System.Globalization;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using MarkMpn.Sql4Cds.Engine.Visitors;
using Microsoft.Crm.Sdk.Messages;
using Microsoft.SqlServer.TransactSql.ScriptDom;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Tooling.Connector;

namespace MarkMpn.Sql4Cds.Engine.ExecutionPlan
{
    /// <summary>
    /// Converts ScriptDom expressions to compiled functions and checks the types of values that will be generated
    /// </summary>
    static class ExpressionExtensions
    {
        /// <summary>
        /// Gets the type of value that will be generated by an expression
        /// </summary>
        /// <param name="expr">The expression to get the type of</param>
        /// <param name="schema">The schema of the node that the expression will be evaluated in the context of</param>
        /// <param name="nonAggregateSchema">For aggregate queries, the schema of the data prior to applying the aggregation</param>
        /// <param name="parameterTypes">A mapping of parameter names to their types that are available to the expression</param>
        /// <returns>The type of value that will be returned by the expression</returns>
        public static Type GetType(this TSqlFragment expr, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes)
        {
            var entityParam = Expression.Parameter(typeof(Entity));
            var parameterParam = Expression.Parameter(typeof(IDictionary<string, object>));
            var optionsParam = Expression.Parameter(typeof(IQueryExecutionOptions));

            var expression = ToExpression(expr, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            return expression.Type;
        }

        /// <summary>
        /// Compiles an expression to a function
        /// </summary>
        /// <param name="expr">The expression to be compiled</param>
        /// <param name="schema">The schema of the node that the expression will be evaluated in the context of</param>
        /// <param name="parameterTypes">A mapping of parameter names to their types that are available to the expression</param>
        /// <returns>A function that accepts a <see cref="Entity"/> representing the data values of a record, a <see cref="IDictionary{string, object}"/> holding parameter values and an <see cref="IQueryExecutionOptions"/> defining how the query should be run and returns the value of the expression</returns>
        public static Func<Entity, IDictionary<string, object>, IQueryExecutionOptions, object> Compile(this TSqlFragment expr, NodeSchema schema, IDictionary<string, DataTypeReference> parameterTypes)
        {
            var entityParam = Expression.Parameter(typeof(Entity));
            var parameterParam = Expression.Parameter(typeof(IDictionary<string, object>));
            var optionsParam = Expression.Parameter(typeof(IQueryExecutionOptions));

            var expression = ToExpression(expr, schema, null, parameterTypes, entityParam, parameterParam, optionsParam);
            expression = Expr.Box(expression);

            return Expression.Lambda<Func<Entity, IDictionary<string, object>, IQueryExecutionOptions, object>>(expression, entityParam, parameterParam, optionsParam).Compile();
        }

        /// <summary>
        /// Compiles a boolean expression to a function
        /// </summary>
        /// <param name="b">The expression to be compiled</param>
        /// <param name="schema">The schema of the node that the expression will be evaluated in the context of</param>
        /// <param name="parameterTypes">A mapping of parameter names to their types that are available to the expression</param>
        /// <returns>A function that accepts a <see cref="Entity"/> representing the data values of a record, a <see cref="IDictionary{string, object}"/> holding parameter values and an <see cref="IQueryExecutionOptions"/> defining how the query should be run and returns the value of the expression</returns>
        public static Func<Entity, IDictionary<string, object>, IQueryExecutionOptions, bool> Compile(this BooleanExpression b, NodeSchema schema, IDictionary<string, DataTypeReference> parameterTypes)
        {
            var entityParam = Expression.Parameter(typeof(Entity));
            var parameterParam = Expression.Parameter(typeof(IDictionary<string, object>));
            var optionsParam = Expression.Parameter(typeof(IQueryExecutionOptions));

            var expression = ToExpression(b, schema, null, parameterTypes, entityParam, parameterParam, optionsParam);
            expression = Expression.IsTrue(expression);
            return Expression.Lambda<Func<Entity, IDictionary<string, object>, IQueryExecutionOptions, bool>>(expression, entityParam, parameterParam, optionsParam).Compile();
        }

        private static Expression ToExpression(this TSqlFragment expr, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            if (expr is ColumnReferenceExpression col)
                return ToExpression(col, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is IdentifierLiteral guid)
                return ToExpression(guid, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is IntegerLiteral i)
                return ToExpression(i, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is MoneyLiteral money)
                return ToExpression(money, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is NullLiteral n)
                return ToExpression(n, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is NumericLiteral num)
                return ToExpression(num, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is RealLiteral real)
                return ToExpression(real, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is StringLiteral str)
                return ToExpression(str, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is OdbcLiteral odbc)
                return ToExpression(odbc, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is BooleanBinaryExpression boolBin)
                return ToExpression(boolBin, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is BooleanComparisonExpression cmp)
                return ToExpression(cmp, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is BooleanParenthesisExpression boolParen)
                return ToExpression(boolParen, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is InPredicate inPred)
                return ToExpression(inPred, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is BooleanIsNullExpression isNull)
                return ToExpression(isNull, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is LikePredicate like)
                return ToExpression(like, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is BooleanNotExpression not)
                return ToExpression(not, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is FullTextPredicate fullText)
                return ToExpression(fullText, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is Microsoft.SqlServer.TransactSql.ScriptDom.BinaryExpression bin)
                return ToExpression(bin, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is FunctionCall func)
                return ToExpression(func, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is ParenthesisExpression paren)
                return ToExpression(paren, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is Microsoft.SqlServer.TransactSql.ScriptDom.UnaryExpression unary)
                return ToExpression(unary, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is VariableReference var)
                return ToExpression(var, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is SimpleCaseExpression simpleCase)
                return ToExpression(simpleCase, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is SearchedCaseExpression searchedCase)
                return ToExpression(searchedCase, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is ConvertCall convert)
                return ToExpression(convert, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is CastCall cast)
                return ToExpression(cast, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else if (expr is ParameterlessCall parameterless)
                return ToExpression(parameterless, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            else
                throw new NotSupportedQueryFragmentException("Unhandled expression type", expr);
        }

        private static Expression ToExpression(ColumnReferenceExpression col, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            var name = col.GetColumnName();

            if (schema == null || !schema.ContainsColumn(name, out var normalizedName))
            {
                if (schema == null || !schema.Aliases.TryGetValue(name, out var normalized))
                {
                    if (nonAggregateSchema != null && nonAggregateSchema.ContainsColumn(name, out _))
                        throw new NotSupportedQueryFragmentException("Column is invalid in the select list because it is not contained in either an aggregate function or the GROUP BY clause", col);

                    var ex = new NotSupportedQueryFragmentException("Unknown column", col);

                    if (col.MultiPartIdentifier.Identifiers.Count == 1 && col.MultiPartIdentifier.Identifiers[0].QuoteType == QuoteType.DoubleQuote)
                        ex.Suggestion = $"Did you mean '{name}'?";
                    else if (name.Equals("false", StringComparison.OrdinalIgnoreCase))
                        ex.Suggestion = "Did you mean '0'?";
                    else if (name.Equals("true", StringComparison.OrdinalIgnoreCase))
                        ex.Suggestion = "Did you mean '1'?";

                    throw ex;
                }

                throw new NotSupportedQueryFragmentException("Ambiguous column reference", col)
                {
                    Suggestion = $"Did you mean:\r\n{String.Join("\r\n", normalized.Select(c => $"* {c}"))}"
                };
            }

            var type = schema.Schema[normalizedName];
            var expr = Expression.Property(entityParam, typeof(Entity).GetCustomAttribute<DefaultMemberAttribute>().MemberName, Expression.Constant(normalizedName));
            return Expression.Convert(expr, type.ToNetType(out _));
        }

        private static Expression ToExpression(IdentifierLiteral guid, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            return Expression.Constant(new SqlGuid(guid.Value));
        }

        private static Expression ToExpression(IntegerLiteral i, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            return Expression.Constant(new SqlInt32(Int32.Parse(i.Value, CultureInfo.InvariantCulture)));
        }

        private static Expression ToExpression(MoneyLiteral money, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            return Expression.Constant(new SqlDecimal(Decimal.Parse(money.Value, CultureInfo.InvariantCulture)));
        }

        private static Expression ToExpression(NullLiteral n, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            return Expression.Constant(null);
        }

        private static Expression ToExpression(NumericLiteral num, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            return Expression.Constant(new SqlDecimal(Decimal.Parse(num.Value, CultureInfo.InvariantCulture)));
        }

        private static Expression ToExpression(RealLiteral real, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            return Expression.Constant(new SqlSingle(Single.Parse(real.Value, CultureInfo.InvariantCulture)));
        }

        private static Expression ToExpression(StringLiteral str, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            return Expression.Constant(new SqlString(str.Value, CultureInfo.CurrentCulture.LCID, SqlCompareOptions.IgnoreCase | SqlCompareOptions.IgnoreNonSpace));
        }

        private static Expression ToExpression(OdbcLiteral odbc, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            switch (odbc.OdbcLiteralType)
            {
                case OdbcLiteralType.Date:
                    return Expression.Constant(new SqlDateTime(DateTime.ParseExact(odbc.Value, "yyyy'-'MM'-'dd", CultureInfo.CurrentCulture, DateTimeStyles.None)));

                case OdbcLiteralType.Timestamp:
                    return Expression.Constant(new SqlDateTime(DateTime.ParseExact(odbc.Value, "yyyy'-'MM'-'dd HH':'mm':'ss", CultureInfo.CurrentCulture, DateTimeStyles.None)));

                case OdbcLiteralType.Guid:
                    return Expression.Constant(new SqlGuid(odbc.Value));

                default:
                    throw new NotSupportedQueryFragmentException("Unknown literal type", odbc);
            }
        }

        private static Expression ToExpression(BooleanComparisonExpression cmp, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            // Special case for field = func() where func is defined in FetchXmlConditionMethods
            if (cmp.FirstExpression is ColumnReferenceExpression &&
                cmp.ComparisonType == BooleanComparisonType.Equals &&
                cmp.SecondExpression is FunctionCall func
                )
            {
                var parameters = func.Parameters.Select(p => p.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam)).ToList();
                parameters.Insert(0, cmp.FirstExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam));
                var paramTypes = parameters.Select(p => p.Type).ToArray();
                var paramExpressions = parameters.ToArray();

                var fetchXmlComparison = GetMethod(typeof(FetchXmlConditionMethods), func, paramTypes, false, optionsParam, ref paramExpressions);

                if (fetchXmlComparison != null)
                    return Expr.Call(fetchXmlComparison, paramExpressions);
            }

            var lhs = cmp.FirstExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            var rhs = cmp.SecondExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);

            if (!SqlTypeConverter.CanMakeConsistentTypes(lhs.Type, rhs.Type, out var type))
            {
                // Special case - we can filter on entity reference types by string
                if (lhs.Type == typeof(SqlEntityReference) && rhs.Type == typeof(SqlString) ||
                    lhs.Type == typeof(SqlString) && rhs.Type == typeof(SqlEntityReference))
                {
                    type = typeof(SqlGuid);
                }
                else
                {
                    throw new NotSupportedQueryFragmentException($"No implicit conversion exists for types {lhs.Type.Name} and {rhs.Type.Name}", cmp);
                }
            }

            if (lhs.Type != type)
                lhs = SqlTypeConverter.Convert(lhs, type);

            if (rhs.Type != type)
            {
                // Special case to give more helpful & earlier error reporting for common problems
                if (cmp.FirstExpression is ColumnReferenceExpression col &&
                    cmp.SecondExpression is StringLiteral str &&
                    (
                        type == typeof(SqlInt32) && !Int32.TryParse(str.Value, out _)
                        ||
                        type == typeof(SqlGuid) && !Guid.TryParse(str.Value, out _)
                    ) &&
                    schema.ContainsColumn(col.GetColumnName() + "name", out var nameCol))
                {
                    throw new NotSupportedQueryFragmentException($"Cannot convert text value to {type.Name}", str)
                    {
                        Suggestion = $"Did you mean to filter on the {nameCol} column instead?\r\n" + new string(' ', 26 + nameCol.Length) + "^^^^"
                    };
                }

                rhs = SqlTypeConverter.Convert(rhs, type);
            }

            switch (cmp.ComparisonType)
            {
                case BooleanComparisonType.Equals:
                    return Expression.Equal(lhs, rhs);

                case BooleanComparisonType.GreaterThan:
                    return Expression.GreaterThan(lhs, rhs);

                case BooleanComparisonType.GreaterThanOrEqualTo:
                case BooleanComparisonType.NotLessThan:
                    return Expression.GreaterThanOrEqual(lhs, rhs);

                case BooleanComparisonType.LessThan:
                    return Expression.LessThan(lhs, rhs);

                case BooleanComparisonType.LessThanOrEqualTo:
                case BooleanComparisonType.NotGreaterThan:
                    return Expression.LessThanOrEqual(lhs, rhs);

                case BooleanComparisonType.NotEqualToBrackets:
                case BooleanComparisonType.NotEqualToExclamation:
                    return Expression.NotEqual(lhs, rhs);

                default:
                    throw new NotSupportedQueryFragmentException("Unknown comparison type", cmp);
            }
        }

        private static Expression ToExpression(BooleanBinaryExpression bin, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            var lhs = bin.FirstExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            var rhs = bin.SecondExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);

            if (bin.BinaryExpressionType == BooleanBinaryExpressionType.And)
                return Expression.AndAlso(lhs, rhs);

            return Expression.OrElse(lhs, rhs);
        }

        private static Expression ToExpression(BooleanParenthesisExpression paren, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            return paren.Expression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
        }

        private static Expression ToExpression(Microsoft.SqlServer.TransactSql.ScriptDom.BinaryExpression bin, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            var lhs = bin.FirstExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            var rhs = bin.SecondExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);

            if (!SqlTypeConverter.CanMakeConsistentTypes(lhs.Type, rhs.Type, out var type))
                throw new NotSupportedQueryFragmentException($"No implicit conversion exists for types {lhs.Type} and {rhs.Type}", bin);

            if (lhs.Type != type)
                lhs = SqlTypeConverter.Convert(lhs, type);

            if (rhs.Type != type)
                rhs = SqlTypeConverter.Convert(rhs, type);

            switch (bin.BinaryExpressionType)
            {
                case BinaryExpressionType.Add:
                    // Special case for SqlDateTime
                    if (lhs.Type == typeof(SqlDateTime) && rhs.Type == typeof(SqlDateTime))
                        return Expr.Call(() => AddSqlDateTime(Expr.Arg<SqlDateTime>(), Expr.Arg<SqlDateTime>()), lhs, rhs);

                    return Expression.Add(lhs, rhs);

                case BinaryExpressionType.Subtract:
                    // Special case for SqlDateTime
                    if (lhs.Type == typeof(SqlDateTime) && rhs.Type == typeof(SqlDateTime))
                        return Expr.Call(() => SubtractSqlDateTime(Expr.Arg<SqlDateTime>(), Expr.Arg<SqlDateTime>()), lhs, rhs);

                    return Expression.Subtract(lhs, rhs);

                case BinaryExpressionType.Multiply:
                    return Expression.Multiply(lhs, rhs);

                case BinaryExpressionType.Divide:
                    return Expression.Divide(lhs, rhs);

                case BinaryExpressionType.Modulo:
                    return Expression.Modulo(lhs, rhs);

                case BinaryExpressionType.BitwiseAnd:
                    return Expression.And(lhs, rhs);

                case BinaryExpressionType.BitwiseOr:
                    return Expression.Or(lhs, rhs);

                case BinaryExpressionType.BitwiseXor:
                    return Expression.ExclusiveOr(lhs, rhs);

                default:
                    throw new NotSupportedQueryFragmentException("Unknown operator", bin);
            }
        }

        private static SqlDateTime AddSqlDateTime(SqlDateTime lhs, SqlDateTime rhs)
        {
            if (lhs.IsNull || rhs.IsNull)
                return SqlDateTime.Null;

            // Convert the second value to the TimeSpan difference between 1900-01-01 and the given value first
            var ts = rhs.Value - new DateTime(1900, 1, 1);
            return lhs + ts;
        }

        private static SqlDateTime SubtractSqlDateTime(SqlDateTime lhs, SqlDateTime rhs)
        {
            if (lhs.IsNull || rhs.IsNull)
                return SqlDateTime.Null;

            // Convert the second value to the TimeSpan difference between 1900-01-01 and the given value first
            var ts = rhs.Value - new DateTime(1900, 1, 1);
            return lhs - ts;
        }

        private static MethodInfo GetMethod(FunctionCall func, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam, out Expression[] paramExpressions)
        {
            // Special case for DATEPART / DATEDIFF / DATEADD - first parameter looks like a field but is actually an identifier
            if (func.FunctionName.Value.Equals("DATEPART", StringComparison.OrdinalIgnoreCase) ||
                func.FunctionName.Value.Equals("DATEDIFF", StringComparison.OrdinalIgnoreCase) ||
                func.FunctionName.Value.Equals("DATEADD", StringComparison.OrdinalIgnoreCase))
            {
                paramExpressions = func.Parameters
                    .Select((param, index) =>
                    {
                        if (index == 0)
                        {
                            // Check parameter is an expected datepart value
                            if (!(param is ColumnReferenceExpression col))
                                throw new NotSupportedQueryFragmentException("Expected a datepart name", param);

                            try
                            {
                                ExpressionFunctions.DatePartToInterval(col.MultiPartIdentifier.Identifiers.Single().Value);
                            }
                            catch
                            {
                                throw new NotSupportedQueryFragmentException("Expected a datepart name", param);
                            }

                            return Expression.Constant(col.MultiPartIdentifier.Identifiers.Single().Value);
                        }

                        return param.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
                    })
                    .ToArray();
            }
            else
            {
                paramExpressions = func.Parameters
                    .Select(param => param.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam))
                    .ToArray();
            }

            return GetMethod(typeof(ExpressionFunctions), func, paramExpressions.Select(expr => expr.Type).ToArray(), true, optionsParam, ref paramExpressions);
        }

        private static MethodInfo GetMethod(Type targetType, FunctionCall func, Type[] paramTypes, bool throwOnMissing, Expression optionsParam, ref Expression[] paramExpressions)
        {
            // Find a method that implements this function
            var methods = targetType
                .GetMethods(BindingFlags.InvokeMethod | BindingFlags.Public | BindingFlags.Static)
                .Where(m => m.Name.Equals(func.FunctionName.Value, StringComparison.OrdinalIgnoreCase))
                .ToList();

            if (methods.Count == 0)
            {
                if (throwOnMissing)
                    throw new NotSupportedQueryFragmentException("Unknown function", func);

                return null;
            }

            // Check parameter count is correct
            var correctParameterCount = methods
                .Select(m => new { Method = m, Parameters = m.GetParameters() })
                .Where(m => 
                    m.Parameters.Length == paramTypes.Length ||
                    (m.Parameters.Length < paramTypes.Length && m.Parameters.Length > 0 && m.Parameters.Last().ParameterType.IsArray) ||
                    (m.Parameters.Length == paramTypes.Length + 1 && m.Parameters.Last().ParameterType == typeof(IQueryExecutionOptions))
                    )
                .ToList();

            if (correctParameterCount.Count == 0)
                throw new NotSupportedQueryFragmentException($"Method expects {methods[0].GetParameters().Length} parameters", func);

            if (correctParameterCount.Count > 1)
                throw new NotSupportedQueryFragmentException("Ambiguous method", func);

            var method = correctParameterCount[0].Method;
            var parameters = correctParameterCount[0].Parameters;

            if (correctParameterCount[0].Method.IsGenericMethodDefinition)
            {
                // Create the generic method based on the type of the generic arguments
                var genericArguments = correctParameterCount[0].Method.GetGenericArguments();
                var genericArgumentValues = new Type[genericArguments.Length];

                foreach (var param in correctParameterCount[0].Parameters)
                {
                    for (var i = 0; i < genericArguments.Length; i++)
                    {
                        if (param.ParameterType == genericArguments[i] && genericArgumentValues[i] == null)
                            genericArgumentValues[i] = paramTypes[i];
                    }
                }

                method = method.MakeGenericMethod(genericArgumentValues);
                parameters = method.GetParameters();
            }

            // Check parameter types can be converted
            var paramOffset = targetType == typeof(FetchXmlConditionMethods) ? 1 : 0;

            for (var i = 0; i < parameters.Length; i++)
            {
                var paramType = parameters[i].ParameterType;

                if (i == parameters.Length - 1 && paramTypes.Length >= parameters.Length && paramType.IsArray)
                    paramType = paramType.GetElementType();

                if (i == parameters.Length - 1 && paramTypes.Length < parameters.Length && paramType == typeof(IQueryExecutionOptions))
                {
                    var paramsWithOptions = new Expression[paramExpressions.Length + 1];
                    paramExpressions.CopyTo(paramsWithOptions, 0);
                    paramsWithOptions[paramExpressions.Length] = optionsParam;
                    paramExpressions = paramsWithOptions;
                    break;
                }

                if (!SqlTypeConverter.CanChangeTypeImplicit(paramTypes[i], paramType))
                    throw new NotSupportedQueryFragmentException($"Cannot convert {paramTypes[i]} to {paramType}", i < paramOffset ? func : func.Parameters[i - paramOffset]);
            }

            for (var i = parameters.Length; i < paramTypes.Length; i++)
            {
                var paramType = parameters.Last().ParameterType.GetElementType();

                if (!SqlTypeConverter.CanChangeTypeImplicit(paramTypes[i], paramType))
                    throw new NotSupportedQueryFragmentException($"Cannot convert {paramTypes[i]} to {paramType}", i < paramOffset ? func : func.Parameters[i - paramOffset]);
            }

            return method;
        }

        private static Expression ToExpression(this FunctionCall func, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            // Find the method to call and get the expressions for the parameter values
            var method = GetMethod(func, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam, out var paramValues);

            // Convert the parameters to the expected types
            var parameters = method.GetParameters();

            for (var i = 0; i < parameters.Length; i++)
            {
                if (paramValues[i].Type != parameters[i].ParameterType)
                    paramValues[i] = SqlTypeConverter.Convert(paramValues[i], parameters[i].ParameterType);
            }

            return Expression.Call(method, paramValues);
        }

        private static Expression ToExpression(this ParenthesisExpression paren, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            return paren.Expression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
        }

        private static Expression ToExpression(this Microsoft.SqlServer.TransactSql.ScriptDom.UnaryExpression unary, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            var value = unary.Expression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            
            switch (unary.UnaryExpressionType)
            {
                case UnaryExpressionType.Positive:
                    return Expression.UnaryPlus(value);

                case UnaryExpressionType.Negative:
                    return Expression.Negate(value);

                case UnaryExpressionType.BitwiseNot:
                    return Expression.Not(value);

                default:
                    throw new NotSupportedQueryFragmentException("Unknown unary operator", unary);
            }
        }

        private static Expression ToExpression(this InPredicate inPred, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            if (inPred.Subquery != null)
                throw new NotSupportedQueryFragmentException("Subquery should have been eliminated by query plan", inPred);

            var exprValue = inPred.Expression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);

            Expression result = null;

            foreach (var value in inPred.Values)
            {
                var comparisonValue = value.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);

                if (!SqlTypeConverter.CanMakeConsistentTypes(exprValue.Type, comparisonValue.Type, out var type))
                    throw new NotSupportedQueryFragmentException($"No implicit conversion exists for types {exprValue.Type} and {comparisonValue.Type}", inPred);

                var convertedExprValue = exprValue;

                if (exprValue.Type != type)
                    convertedExprValue = SqlTypeConverter.Convert(convertedExprValue, type);

                if (comparisonValue.Type != type)
                    comparisonValue = SqlTypeConverter.Convert(comparisonValue, type);

                var comparison = inPred.NotDefined ? Expression.NotEqual(convertedExprValue, comparisonValue) : Expression.Equal(convertedExprValue, comparisonValue);

                if (result == null)
                    result = comparison;
                else
                    result = inPred.NotDefined ? Expression.AndAlso(result, comparison) : Expression.OrElse(result, comparison);
            }

            return result;
        }

        private static Expression ToExpression(this VariableReference var, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            if (parameterTypes == null || !parameterTypes.TryGetValue(var.Name, out var type))
                throw new NotSupportedQueryFragmentException("Undefined variable", var);

            var expr = Expression.Property(parameterParam, typeof(IDictionary<string,object>).GetCustomAttribute<DefaultMemberAttribute>().MemberName, Expression.Constant(var.Name));
            return Expression.Convert(expr, type.ToNetType(out _));
        }

        private static Expression ToExpression(this BooleanIsNullExpression isNull, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            var value = isNull.Expression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            value = SqlTypeConverter.NullCheck(value);

            if (isNull.IsNot)
                value = Expression.Not(value);

            value = SqlTypeConverter.Convert(value, typeof(SqlBoolean));
            return value;
        }

        private static Expression ToExpression(this LikePredicate like, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            var value = like.FirstExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            var pattern = like.SecondExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            var escape = like.EscapeExpression?.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);

            if (value.Type != typeof(SqlString))
            {
                if (!SqlTypeConverter.CanChangeTypeImplicit(value.Type, typeof(SqlString)))
                    throw new NotSupportedQueryFragmentException("Cannot convert value to string", like.FirstExpression);

                value = SqlTypeConverter.Convert(value, typeof(SqlString));
            }

            if (pattern.Type != typeof(SqlString))
            {
                if (!SqlTypeConverter.CanChangeTypeImplicit(pattern.Type, typeof(SqlString)))
                    throw new NotSupportedQueryFragmentException("Cannot convert pattern to string", like.SecondExpression);

                pattern = SqlTypeConverter.Convert(pattern, typeof(SqlString));
            }

            if (escape != null && escape.Type != typeof(SqlString))
            {
                if (!SqlTypeConverter.CanChangeTypeImplicit(escape.Type, typeof(SqlString)))
                    throw new NotSupportedQueryFragmentException("Cannot convert escape sequence to string", like.EscapeExpression);

                escape = SqlTypeConverter.Convert(escape, typeof(SqlString));
            }

            if (escape == null)
                escape = Expression.Constant(SqlString.Null);

            if (pattern.NodeType == ExpressionType.Constant && (escape == null || escape.NodeType == ExpressionType.Constant))
            {
                // Do a one-off conversion to regex
                try
                {
                    var regex = LikeToRegex((SqlString)((ConstantExpression)pattern).Value, (SqlString)(((ConstantExpression)escape)?.Value ?? SqlString.Null));
                    return Expr.Call(() => Like(Expr.Arg<SqlString>(), Expr.Arg<Regex>(), Expr.Arg<bool>()), value, Expression.Constant(regex), Expression.Constant(like.NotDefined));
                }
                catch (ArgumentException ex)
                {
                    throw new NotSupportedQueryFragmentException(ex.Message, like.SecondExpression);
                }
            }

            return Expr.Call(() => Like(Expr.Arg<SqlString>(), Expr.Arg<SqlString>(), Expr.Arg<SqlString>(), Expr.Arg<bool>()), value, pattern, escape, Expression.Constant(like.NotDefined));
        }

        private static Regex LikeToRegex(SqlString pattern, SqlString escape)
        {
            var regexBuilder = new StringBuilder();
            regexBuilder.Append("^");

            var escaped = false;
            var inRange = false;
            var escapeChar = escape.IsNull ? '\0' : escape.Value[0];

            foreach (var ch in pattern.Value)
            {
                if (escapeChar != '\0' && ch == escapeChar)
                {
                    escaped = true;
                    continue;
                }

                if (escaped)
                {
                    regexBuilder.Append(Regex.Escape(ch.ToString()));
                    escaped = false;
                    continue;
                }

                if (ch == '[' && !inRange)
                {
                    regexBuilder.Append("[");
                    inRange = true;
                    continue;
                }

                if (ch == ']' && inRange)
                {
                    regexBuilder.Append("]");
                    inRange = false;
                    continue;
                }

                if ((ch == '^' || ch == '-') && inRange)
                {
                    regexBuilder.Append(ch);
                    continue;
                }

                if (inRange)
                {
                    regexBuilder.Append(Regex.Escape(ch.ToString()));
                    continue;
                }

                if (ch == '%')
                {
                    regexBuilder.Append(".*");
                    continue;
                }

                if (ch == '_')
                {
                    regexBuilder.Append('.');
                    continue;
                }

                regexBuilder.Append(Regex.Escape(ch.ToString()));
            }

            if (escaped || inRange)
                throw new ArgumentException("Invalid LIKE pattern");

            regexBuilder.Append("$");

            return new Regex(regexBuilder.ToString(), RegexOptions.IgnoreCase);
        }

        private static SqlBoolean Like(SqlString value, SqlString pattern, SqlString escape, bool not)
        {
            if (value.IsNull || pattern.IsNull)
                return false;

            // Convert the LIKE pattern to a regex
            var regex = LikeToRegex(pattern, escape);
            var result = regex.IsMatch(value.Value);

            if (not)
                result = !result;

            return result;
        }

        private static SqlBoolean Like(SqlString value, Regex pattern, bool not)
        {
            if (value.IsNull)
                return false;

            var result = pattern.IsMatch(value.Value);

            if (not)
                result = !result;

            return result;
        }

        private static Expression ToExpression(this SimpleCaseExpression simpleCase, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            // Convert all the different elements to expressions
            var value = simpleCase.InputExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            var whenClauses = simpleCase.WhenClauses.Select(when => when.WhenExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam)).ToList();
            var caseTypes = new Type[whenClauses.Count];
            var thenClauses = simpleCase.WhenClauses.Select(when => when.ThenExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam)).ToList();
            var elseValue = simpleCase.ElseExpression?.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);

            // First pass to determine final return type
            Type type = null;

            for (var i = 0; i < simpleCase.WhenClauses.Count; i++)
            {
                var whenType = whenClauses[i].Type;

                if (!SqlTypeConverter.CanMakeConsistentTypes(value.Type, whenType, out var caseType))
                    throw new NotSupportedQueryFragmentException($"Cannot compare values of type {value.Type} and {whenType}", simpleCase.WhenClauses[i].WhenExpression);

                caseTypes[i] = caseType;

                var thenType = thenClauses[i].Type;

                if (type == null)
                    type = thenType;
                else if (!SqlTypeConverter.CanMakeConsistentTypes(type, thenType, out type))
                    throw new NotSupportedQueryFragmentException($"Cannot determine return type", simpleCase);
            }

            if (elseValue != null)
            {
                var elseType = elseValue.Type;

                if (type == null)
                    type = elseType;
                else if (!SqlTypeConverter.CanMakeConsistentTypes(type, elseType, out type))
                    throw new NotSupportedQueryFragmentException($"Cannot determine return type", simpleCase);
            }

            // Second pass to build up the calculation. Do this in reverse so we can keep wrapping the previous expression in more conditions to
            // add the earlier cases
            Expression result = null;

            if (elseValue != null)
            {
                if (elseValue.Type != type)
                    elseValue = SqlTypeConverter.Convert(elseValue, type);

                result = elseValue;
            }
            else
            {
                result = Expression.Constant(SqlTypeConverter.GetNullValue(type));
            }

            for (var i = simpleCase.WhenClauses.Count - 1; i >= 0; i--)
            {
                var valueCopy = value;
                var whenValue = whenClauses[i];
                var caseType = caseTypes[i];

                if (value.Type != caseType)
                    valueCopy = SqlTypeConverter.Convert(valueCopy, caseType);

                if (whenValue.Type != caseType)
                    whenValue = SqlTypeConverter.Convert(whenValue, type);

                var comparison = Expression.Equal(valueCopy, whenValue);
                var returnValue = thenClauses[i];

                if (returnValue.Type != type)
                    returnValue = SqlTypeConverter.Convert(returnValue, type);

                result = Expression.Condition(Expression.IsTrue(comparison), returnValue, result);
            }

            return result;
        }

        private static Expression ToExpression(this SearchedCaseExpression searchedCase, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            // Convert all the different elements to expressions
            var whenClauses = searchedCase.WhenClauses.Select(when => when.WhenExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam)).ToList();
            var thenClauses = searchedCase.WhenClauses.Select(when => when.ThenExpression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam)).ToList();
            var elseValue = searchedCase.ElseExpression?.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);

            // First pass to determine final return type
            Type type = null;

            for (var i = 0; i < thenClauses.Count; i++)
            {
                var thenType = thenClauses[i].Type;

                if (type == null)
                    type = thenType;
                else if (!SqlTypeConverter.CanMakeConsistentTypes(type, thenType, out type))
                    throw new NotSupportedQueryFragmentException($"Cannot determine return type", searchedCase);
            }

            if (elseValue != null)
            {
                var elseType = elseValue.Type;

                if (type == null)
                    type = elseType;
                else if (!SqlTypeConverter.CanMakeConsistentTypes(type, elseType, out type))
                    throw new NotSupportedQueryFragmentException($"Cannot determine return type", searchedCase);
            }

            // Second pass to build up the calculation. Do this in reverse so we can keep wrapping the previous expression in more conditions to
            // add the earlier cases
            Expression result = null;

            if (elseValue != null)
            {
                if (elseValue.Type != type)
                    elseValue = SqlTypeConverter.Convert(elseValue, type);

                result = elseValue;
            }
            else
            {
                result = Expression.Constant(SqlTypeConverter.GetNullValue(type));
            }

            for (var i = whenClauses.Count - 1; i >= 0; i--)
            {
                var whenValue = whenClauses[i];
                var returnValue = thenClauses[i];

                whenValue = SqlTypeConverter.Convert(whenValue, typeof(SqlBoolean));
                whenValue = Expression.IsTrue(whenValue);

                returnValue = SqlTypeConverter.Convert(returnValue, type);

                result = Expression.Condition(whenValue, returnValue, result);
            }

            return result;
        }

        private static Expression ToExpression(this BooleanNotExpression not, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            var value = not.Expression.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            return Expression.Not(value);
        }

        private static readonly Dictionary<SqlDataTypeOption, Type> _typeMapping = new Dictionary<SqlDataTypeOption, Type>
        {
            [SqlDataTypeOption.BigInt] = typeof(SqlInt64),
            [SqlDataTypeOption.Binary] = typeof(SqlBinary),
            [SqlDataTypeOption.Bit] = typeof(SqlBoolean),
            [SqlDataTypeOption.Char] = typeof(SqlString),
            [SqlDataTypeOption.Date] = typeof(SqlDateTime),
            [SqlDataTypeOption.DateTime] = typeof(SqlDateTime),
            [SqlDataTypeOption.DateTime2] = typeof(SqlDateTime),
            [SqlDataTypeOption.DateTimeOffset] = typeof(SqlDateTime),
            [SqlDataTypeOption.Decimal] = typeof(SqlDecimal),
            [SqlDataTypeOption.Float] = typeof(SqlDouble),
            [SqlDataTypeOption.Image] = typeof(SqlBinary),
            [SqlDataTypeOption.Int] = typeof(SqlInt32),
            [SqlDataTypeOption.Money] = typeof(SqlMoney),
            [SqlDataTypeOption.NChar] = typeof(SqlString),
            [SqlDataTypeOption.NText] = typeof(SqlString),
            [SqlDataTypeOption.Numeric] = typeof(SqlDecimal),
            [SqlDataTypeOption.NVarChar] = typeof(SqlString),
            [SqlDataTypeOption.Real] = typeof(SqlSingle),
            [SqlDataTypeOption.SmallDateTime] = typeof(SqlDateTime),
            [SqlDataTypeOption.SmallInt] = typeof(SqlInt16),
            [SqlDataTypeOption.SmallMoney] = typeof(SqlMoney),
            [SqlDataTypeOption.Text] = typeof(SqlString),
            [SqlDataTypeOption.TinyInt] = typeof(SqlByte),
            [SqlDataTypeOption.UniqueIdentifier] = typeof(SqlGuid),
            [SqlDataTypeOption.VarBinary] = typeof(SqlBinary),
            [SqlDataTypeOption.VarChar] = typeof(SqlString),
            [SqlDataTypeOption.Sql_Variant] = typeof(object)
        };

        /// <summary>
        /// Converts a SQL <see cref="DataTypeReference"/> to the equivalent .NET <see cref="Type"/>
        /// </summary>
        /// <param name="type">The data type to convert</param>
        /// <param name="sqlDataType">If the <paramref name="type"/> is a <see cref="SqlDataTypeReference"/>, this is set to the cast value.</param>
        /// <returns>The equivalent .NET <see cref="Type"/></returns>
        public static Type ToNetType(this DataTypeReference type, out SqlDataTypeReference sqlDataType)
        {
            if (!(type is SqlDataTypeReference dataType))
            {
                if (type is UserDataTypeReference udt && udt.Name.BaseIdentifier.Value == typeof(SqlEntityReference).FullName)
                {
                    sqlDataType = null;
                    return typeof(SqlEntityReference);
                }

                throw new NotSupportedQueryFragmentException("Unsupported data type reference", type);
            }

            sqlDataType = dataType;

            if (!_typeMapping.TryGetValue(dataType.SqlDataTypeOption, out var targetType))
                throw new NotSupportedQueryFragmentException("Unknown type name", type);

            return targetType;
        }

        private static readonly Dictionary<Type, DataTypeReference> _netTypeMapping = new Dictionary<Type, DataTypeReference>
        {
            [typeof(SqlInt64)] = new SqlDataTypeReference { SqlDataTypeOption = SqlDataTypeOption.BigInt },
            [typeof(SqlBinary)] = new SqlDataTypeReference { SqlDataTypeOption = SqlDataTypeOption.Binary },
            [typeof(SqlBoolean)] = new SqlDataTypeReference { SqlDataTypeOption = SqlDataTypeOption.Bit },
            [typeof(SqlString)] = new SqlDataTypeReference { SqlDataTypeOption = SqlDataTypeOption.NVarChar },
            [typeof(SqlDateTime)] = new SqlDataTypeReference { SqlDataTypeOption = SqlDataTypeOption.DateTime },
            [typeof(SqlDecimal)] = new SqlDataTypeReference { SqlDataTypeOption = SqlDataTypeOption.Decimal },
            [typeof(SqlDouble)] = new SqlDataTypeReference { SqlDataTypeOption = SqlDataTypeOption.Float },
            [typeof(SqlInt32)] = new SqlDataTypeReference { SqlDataTypeOption = SqlDataTypeOption.Int },
            [typeof(SqlMoney)] = new SqlDataTypeReference { SqlDataTypeOption = SqlDataTypeOption.Money },
            [typeof(SqlSingle)] = new SqlDataTypeReference { SqlDataTypeOption = SqlDataTypeOption.Real },
            [typeof(SqlInt16)] = new SqlDataTypeReference { SqlDataTypeOption = SqlDataTypeOption.SmallInt },
            [typeof(SqlByte)] = new SqlDataTypeReference { SqlDataTypeOption = SqlDataTypeOption.TinyInt },
            [typeof(SqlGuid)] = new SqlDataTypeReference { SqlDataTypeOption = SqlDataTypeOption.UniqueIdentifier },
            [typeof(SqlEntityReference)] = new UserDataTypeReference { Name = new SchemaObjectName { Identifiers = { new Identifier { Value = typeof(SqlEntityReference).FullName } } } }
        };

        /// <summary>
        /// Converts a .NET <see cref="Type"/> to the equivalent SQL <see cref="DataTypeReference"/>
        /// </summary>
        /// <param name="type">The data type to convert</param>
        /// <returns>The equivalent SQL <see cref="DataTypeReference"/></returns>
        public static DataTypeReference ToSqlType(this Type type)
        {
            return _netTypeMapping[type];
        }

        private static Expression ToExpression(this ConvertCall convert, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            var value = convert.Parameter.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
            var style = convert.Style?.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);

            return SqlTypeConverter.Convert(value, convert.DataType, style, convert);
        }

        private static Expression ToExpression(this CastCall cast, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            return ToExpression(new ConvertCall { Parameter = cast.Parameter, DataType = cast.DataType }, schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);
        }

        private static readonly Regex _containsParser = new Regex("^\\S+( OR \\S+)*$", RegexOptions.IgnoreCase | RegexOptions.Compiled);

        private static Expression ToExpression(this FullTextPredicate fullText, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            // Only support simple CONTAINS calls to handle multi-select optionsets for now
            if (fullText.FullTextFunctionType != FullTextFunctionType.Contains)
                throw new NotSupportedQueryFragmentException("Unsupported full text predicate type", fullText) { Suggestion = "Only CONTAINS is currently supported for full text searching" };

            if (fullText.Columns.Count != 1)
                throw new NotSupportedQueryFragmentException("Only one column is currently supported for CONTAINS function", fullText);

            if (fullText.Columns[0].ColumnType == ColumnType.Wildcard)
                throw new NotSupportedQueryFragmentException("Only one column is currently supported for CONTAINS function", fullText);

            if (fullText.PropertyName != null)
                throw new NotSupportedQueryFragmentException("PROPERTY is not currently supported", fullText.PropertyName);

            if (fullText.LanguageTerm != null)
                throw new NotSupportedQueryFragmentException("LANGUAGE is not currently supported", fullText.LanguageTerm);

            var col = fullText.Columns[0].ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);

            if (!SqlTypeConverter.CanChangeTypeImplicit(col.Type, typeof(SqlString)))
                throw new NotSupportedQueryFragmentException("Only string columns are supported", fullText.Columns[0]);

            col = SqlTypeConverter.Convert(col, typeof(SqlString));

            if (fullText.Value is StringLiteral lit)
            {
                if (!_containsParser.IsMatch(lit.Value))
                    throw new NotSupportedQueryFragmentException("Only simple \"word OR word OR word\" patterns are currently supported", lit);

                var words = GetContainsWords(lit.Value, true);
                return Expr.Call(() => Contains(Expr.Arg<SqlString>(), Expr.Arg<Regex[]>()), col, Expression.Constant(words));
            }

            var value = fullText.Value.ToExpression(schema, nonAggregateSchema, parameterTypes, entityParam, parameterParam, optionsParam);

            if (!SqlTypeConverter.CanChangeTypeImplicit(value.Type, typeof(SqlString)))
                throw new NotSupportedQueryFragmentException($"Expected string value to match, got {value.Type}", fullText.Value);

            value = SqlTypeConverter.Convert(value, typeof(SqlString));

            return Expr.Call(() => Contains(Expr.Arg<SqlString>(), Expr.Arg<SqlString>()), col, value);
        }

        private static SqlBoolean Contains(SqlString col, SqlString value)
        {
            if (col.IsNull || value.IsNull)
                return false;

            var words = GetContainsWords(value.Value, false);
            return Contains(col, words);
        }

        private static SqlBoolean Contains(SqlString col, Regex[] words)
        {
            if (col.IsNull)
                return false;

            return words.Any(w => w.IsMatch(col.Value));
        }

        private static Regex[] GetContainsWords(string pattern, bool compile)
        {
            if (!_containsParser.IsMatch(pattern))
                throw new QueryExecutionException("Invalid CONTAINS pattern. Only simple \"word OR word OR word\" patterns are currently supported");

            var options = RegexOptions.IgnoreCase;
            if (compile)
                options |= RegexOptions.Compiled;

            var words = pattern.ToUpperInvariant().Split(new[] { " OR " }, StringSplitOptions.None);

            return words
                .Select(w => new Regex($@"\b{Regex.Escape(w)}\b", options))
                .ToArray();
        }

        private static Expression ToExpression(this ParameterlessCall parameterless, NodeSchema schema, NodeSchema nonAggregateSchema, IDictionary<string, DataTypeReference> parameterTypes, ParameterExpression entityParam, ParameterExpression parameterParam, ParameterExpression optionsParam)
        {
            switch (parameterless.ParameterlessCallType)
            {
                case ParameterlessCallType.CurrentTimestamp:
                    return Expr.Call(() => GetCurrentTimestamp(Expr.Arg<IQueryExecutionOptions>()), optionsParam);

                default:
                    return Expr.Call(() => GetCurrentUser(Expr.Arg<IQueryExecutionOptions>()), optionsParam);
            }
        }

        private static SqlDateTime GetCurrentTimestamp(IQueryExecutionOptions options)
        {
            if (options.UseLocalTimeZone)
                return new SqlDateTime(DateTime.Now);
            else
                return new SqlDateTime(DateTime.UtcNow);
        }

        private static SqlEntityReference GetCurrentUser(IQueryExecutionOptions options)
        {
            return new SqlEntityReference(options.PrimaryDataSource, "systemuser", options.UserId);
        }

        /// <summary>
        /// Removes a condition from a boolean expression
        /// </summary>
        /// <param name="expr">The full boolean expression</param>
        /// <param name="remove">The condition to remove</param>
        /// <returns>A version of the <paramref name="expr"/> with the expression removed</returns>
        public static BooleanExpression RemoveCondition(this BooleanExpression expr, BooleanExpression remove)
        {
            if (expr == remove)
                return null;

            if (expr is BooleanBinaryExpression binary)
            {
                if (binary.FirstExpression == remove)
                    return binary.SecondExpression;

                if (binary.SecondExpression == remove)
                    return binary.FirstExpression;

                var clone = new BooleanBinaryExpression
                {
                    BinaryExpressionType = binary.BinaryExpressionType,
                    FirstExpression = binary.FirstExpression.RemoveCondition(remove),
                    SecondExpression = binary.SecondExpression.RemoveCondition(remove)
                };

                return clone;
            }

            if (expr is BooleanParenthesisExpression paren)
            {
                if (paren.Expression == remove)
                    return null;

                return new BooleanParenthesisExpression { Expression = paren.Expression.RemoveCondition(remove) };
            }

            return expr;
        }

        /// <summary>
        /// Gets the name of a column
        /// </summary>
        /// <param name="col">A <see cref="ColumnReferenceExpression"/></param>
        /// <returns>The name of the column being referenced</returns>
        public static string GetColumnName(this ColumnReferenceExpression col)
        {
            return String.Join(".", col.MultiPartIdentifier.Identifiers.Select(id => id.Value));
        }

        /// <summary>
        /// Gets a list of columns referenced in an expression
        /// </summary>
        /// <param name="fragment">The expression to get the list of columns from</param>
        /// <returns>A list of column names referenced in the <paramref name="fragment"/></returns>
        public static IEnumerable<string> GetColumns(this TSqlFragment fragment)
        {
            var visitor = new ColumnCollectingVisitor();
            fragment.Accept(visitor);

            return visitor.Columns
                .Where(col => col.ColumnType == ColumnType.Regular)
                .Select(col => col.GetColumnName())
                .Distinct();
        }

        /// <summary>
        /// Gets a list of variables referenced in an expression
        /// </summary>
        /// <param name="fragment">The expression to get the list of variables from</param>
        /// <returns>A list of variable names referenced in the <paramref name="fragment"/></returns>
        public static IEnumerable<string> GetVariables(this TSqlFragment fragment)
        {
            var visitor = new VariableCollectingVisitor();
            fragment.Accept(visitor);

            return visitor.Variables
                .Select(var => var.Name)
                .Distinct();
        }

        /// <summary>
        /// Parses a column name into a <see cref="ColumnReferenceExpression"/>
        /// </summary>
        /// <param name="colName">The column name to parse</param>
        /// <returns>An equivalent <see cref="ColumnReferenceExpression"/></returns>
        public static ColumnReferenceExpression ToColumnReference(this string colName)
        {
            var col = new ColumnReferenceExpression { MultiPartIdentifier = new MultiPartIdentifier() };

            foreach (var part in colName.Split('.'))
                col.MultiPartIdentifier.Identifiers.Add(new Identifier { Value = part });

            return col;
        }

        /// <summary>
        /// Checks if an expression has a constant value
        /// </summary>
        /// <param name="expr">The expression to check</param>
        /// <param name="schema">The schema that the expression is evaluated in</param>
        /// <param name="literal">The equivalent literal value</param>
        /// <returns><c>true</c> if the expression has a constant value, or <c>false</c> if it can change depending on the current data record</returns>
        public static bool IsConstantValueExpression(this ScalarExpression expr, NodeSchema schema, IQueryExecutionOptions options, out Literal literal)
        {
            literal = expr as Literal;

            if (literal != null)
                return true;

            var columnVisitor = new ColumnCollectingVisitor();
            expr.Accept(columnVisitor);

            if (columnVisitor.Columns.Count > 0)
                return false;

            var variableVisitor = new VariableCollectingVisitor();
            expr.Accept(variableVisitor);

            if (variableVisitor.Variables.Count > 0)
                return false;

            var parameterlessVisitor = new ParameterlessCollectingVisitor();
            expr.Accept(parameterlessVisitor);

            if (parameterlessVisitor.ParameterlessCalls.Any(p => p.ParameterlessCallType != ParameterlessCallType.CurrentTimestamp))
                return false;

            var value = expr.Compile(schema, null)(null, null, options);

            if (value == null || value is INullable n && n.IsNull)
                literal = new NullLiteral();
            else if (value is SqlInt32 i)
                literal = new IntegerLiteral { Value = i.ToString() };
            else if (value is SqlDecimal dec)
                literal = new NumericLiteral { Value = dec.ToString() };
            else if (value is SqlDouble dbl)
                literal = new NumericLiteral { Value = dbl.ToString() };
            else if (value is SqlSingle flt)
                literal = new RealLiteral { Value = flt.ToString() };
            else if (value is SqlString str)
                literal = new StringLiteral { Value = str.ToString() };
            else if (value is SqlDateTime dt)
                literal = new StringLiteral { Value = dt.Value.ToString("yyyy-MM-ddTHH:mm:ss.fff") };
            else if (value is SqlGuid g)
                literal = new StringLiteral { Value = g.ToString() };
            else
                return false;

            return true;
        }
    }
}
