using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data.SqlTypes;
using System.Globalization;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using MarkMpn.Sql4Cds.Engine.Visitors;
using Microsoft.SqlServer.TransactSql.ScriptDom;
using Microsoft.Xrm.Sdk;
using Wmhelp.XPath2;

namespace MarkMpn.Sql4Cds.Engine.ExecutionPlan
{
    /// <summary>
    /// Converts ScriptDom expressions to compiled functions and checks the types of values that will be generated
    /// </summary>
    static class ExpressionExtensions
    {
        class CompiledExpression<T>
        {
            public CompiledExpression(TSqlFragment expression, Expression converted, Func<ExpressionExecutionContext, TSqlFragment, T> compiled)
            {
                Expression = expression;
                Converted = converted;
                Compiled = compiled;
            }
            public TSqlFragment Expression { get; }
            public Expression Converted { get; }
            public Func<ExpressionExecutionContext, TSqlFragment, T> Compiled { get; }
        }

        class IntermediateExpression
        {
            public IntermediateExpression(Expression converted, ParameterExpression[] parameters)
            {
                Converted = converted;
                Parameters = parameters;
                Lambda = Expression.Lambda(converted, parameters);
            }
            public Expression Converted { get; }
            public ParameterExpression[] Parameters { get; }
            public LambdaExpression Lambda { get; }
        }

        private static readonly TSqlParser _parser = new TSql160Parser(false);
        private static readonly ConcurrentDictionary<string, CompiledExpression<object>> _cache = new ConcurrentDictionary<string, CompiledExpression<object>>();
        private static readonly ConcurrentDictionary<string, CompiledExpression<bool>> _boolCache = new ConcurrentDictionary<string, CompiledExpression<bool>>();
        private static readonly ConcurrentDictionary<string, IntermediateExpression> _intermediateCache = new ConcurrentDictionary<string, IntermediateExpression>();

        /// <summary>
        /// Gets the type of value that will be generated by an expression
        /// </summary>
        /// <param name="expr">The expression to get the type of</param>
        /// <param name="context">The context the expression is being compiled in</param>
        /// <param name="sqlType">The SQL data type that will be returned</param>
        /// <returns>The type of value that will be returned by the expression</returns>
        public static Type GetType(this TSqlFragment expr, ExpressionCompilationContext context, out DataTypeReference sqlType)
        {
            ToExpression(expr, context, false, out _, out sqlType, out var cacheKey);
            var details = _cache.GetOrAdd(cacheKey, __ =>
            {
                var converted = ToExpression(expr, context, true, out var parameters, out _, out _);
                var compiled = Expression.Lambda<Func<ExpressionExecutionContext, TSqlFragment, object>>(Expr.Box(converted), parameters).Compile();
                return new CompiledExpression<object>(expr, converted, compiled);
            });
            return details.Converted.Type;
        }

        /// <summary>
        /// Compiles an expression to a function
        /// </summary>
        /// <param name="expr">The expression to be compiled</param>
        /// <param name="context">The context the expression is being compiled in</param>
        /// <returns>A function that accepts an <see cref="ExpressionExecutionContext"/> representing the context the expression is being evaluated in and returns the value of the expression</returns>
        public static Func<ExpressionExecutionContext, object> Compile(this TSqlFragment expr, ExpressionCompilationContext context)
        {
            ToExpression(expr, context, false, out _, out _, out var cacheKey);
            var details = _cache.GetOrAdd(cacheKey, __ =>
            {
                var converted = ToExpression(expr, context, true, out var parameters, out _, out _);
                var compiled = Expression.Lambda<Func<ExpressionExecutionContext, TSqlFragment, object>>(Expr.Box(converted), parameters).Compile();
                return new CompiledExpression<object>(expr, converted, compiled);
            });
            return eec => details.Compiled(eec, expr);
        }

        /// <summary>
        /// Compiles a boolean expression to a function
        /// </summary>
        /// <param name="b">The expression to be compiled</param>
        /// <param name="context">The context the expression is being compiled in</param>
        /// <returns>A function that accepts aan <see cref="ExpressionExecutionContext"/> representing the context the expression is being evaluated in and returns the value of the expression</returns>
        public static Func<ExpressionExecutionContext, bool> Compile(this BooleanExpression b, ExpressionCompilationContext context)
        {
            ToExpression(b, context, false, out _, out _, out var cacheKey);
            var details = _boolCache.GetOrAdd(cacheKey, __ =>
            {
                var converted = ToExpression(b, context, true, out var parameters, out _, out _);
                var compiled = Expression.Lambda<Func<ExpressionExecutionContext, TSqlFragment, bool>>(Expression.IsTrue(converted), parameters).Compile();
                return new CompiledExpression<bool>(b, converted, compiled);
            });

            return eec => details.Compiled(eec, b);
        }

        private static Expression ToExpression(this TSqlFragment expr, ExpressionCompilationContext context, bool createExpression, out ParameterExpression[] parameters, out DataTypeReference sqlType, out string cacheKey)
        {
            var contextParam = createExpression ? Expression.Parameter(typeof(ExpressionExecutionContext)) : null;
            var exprParam = createExpression ? Expression.Parameter(typeof(TSqlFragment)) : null;

            Expression expression;

            if (expr is ColumnReferenceExpression col)
                expression = ToExpression(col, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is IdentifierLiteral guid)
                expression = ToExpression(guid, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is IntegerLiteral i)
                expression = ToExpression(i, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is MoneyLiteral money)
                expression = ToExpression(money, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is NullLiteral n)
                expression = ToExpression(n, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is NumericLiteral num)
                expression = ToExpression(num, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is RealLiteral real)
                expression = ToExpression(real, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is StringLiteral str)
                expression = ToExpression(str, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is OdbcLiteral odbc)
                expression = ToExpression(odbc, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is BooleanBinaryExpression boolBin)
                expression = ToExpression(boolBin, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is BooleanComparisonExpression cmp)
                expression = ToExpression(cmp, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is BooleanParenthesisExpression boolParen)
                expression = ToExpression(boolParen, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is InPredicate inPred)
                expression = ToExpression(inPred, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is BooleanIsNullExpression isNull)
                expression = ToExpression(isNull, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is LikePredicate like)
                expression = ToExpression(like, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is BooleanNotExpression not)
                expression = ToExpression(not, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is FullTextPredicate fullText)
                expression = ToExpression(fullText, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is Microsoft.SqlServer.TransactSql.ScriptDom.BinaryExpression bin)
                expression = ToExpression(bin, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is FunctionCall func)
                expression = ToExpression(func, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is ParenthesisExpression paren)
                expression = ToExpression(paren, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is Microsoft.SqlServer.TransactSql.ScriptDom.UnaryExpression unary)
                expression = ToExpression(unary, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is VariableReference var)
                expression = ToExpression(var, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is SimpleCaseExpression simpleCase)
                expression = ToExpression(simpleCase, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is SearchedCaseExpression searchedCase)
                expression = ToExpression(searchedCase, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is ConvertCall convert)
                expression = ToExpression(convert, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is CastCall cast)
                expression = ToExpression(cast, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is ParameterlessCall parameterless)
                expression = ToExpression(parameterless, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is GlobalVariableExpression global)
                expression = ToExpression(global, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is ExpressionCallTarget callTarget)
                expression = ToExpression(callTarget, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else if (expr is DistinctPredicate distinct)
                expression = ToExpression(distinct, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            else
                throw new NotSupportedQueryFragmentException(Sql4CdsError.SyntaxError(expr)) { Suggestion = "Unhandled expression type" };

            if (expr is PrimaryExpression primary && primary.Collation != null)
            {
                if (!Collation.TryParse(primary.Collation.Value, out var coll))
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.InvalidCollation(primary.Collation));

                if (sqlType is SqlDataTypeReferenceWithCollation sqlTypeWithCollation)
                {
                    if (createExpression)
                        expression = Expr.Call(() => SqlTypeConverter.ConvertCollation(Expr.Arg<SqlString>(), Expr.Arg<Collation>()), expression, Expression.Constant(coll));

                    sqlType = new SqlDataTypeReferenceWithCollation
                    {
                        SqlDataTypeOption = sqlTypeWithCollation.SqlDataTypeOption,
                        Collation = coll,
                        CollationLabel = CollationLabel.Explicit
                    };

                    foreach (var param in sqlTypeWithCollation.Parameters)
                        ((SqlDataTypeReferenceWithCollation)sqlType).Parameters.Add(param);

                    cacheKey += " COLLATE " + primary.Collation.Value;
                }
            }

            parameters = createExpression ? new[] { contextParam, exprParam } : null;
            return expression;
        }

        private static Expression InvokeSubExpression<TParent, TChild>(this TParent parent, Func<TParent, TChild> child, Expression<Func<TParent, TChild>> subExpressionSelector, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
            where TParent : TSqlFragment
            where TChild : TSqlFragment
        {
            // Build an expression to invoke the child expression from within the context of the parent expression
            child(parent).ToExpression(context, false, out _, out sqlType, out cacheKey);
            var details = _intermediateCache.GetOrAdd(cacheKey, __ =>
            {
                var converted = child(parent).ToExpression(context, true, out var parameters, out _, out _);
                return new IntermediateExpression(converted, parameters);
            });

            if (!createExpression || exprParam == null)
                return details.Converted;

            if (!(subExpressionSelector is LambdaExpression lambda) ||
                !(lambda.Body is MemberExpression memberAccessor) ||
                !(memberAccessor.Member is PropertyInfo prop))
                throw new ArgumentException("Invalid Expression. Expression should consist of a property accessor only.");

            var subExpr = Expression.Property(Expression.Convert(exprParam, prop.DeclaringType), prop);

            return Expression.Invoke(details.Lambda, contextParam, subExpr);
        }

        private static Expression InvokeSubExpression<TParent, TChild>(this TParent parent, Func<TParent, TChild> child, Expression<Func<TParent, int, TChild>> subExpressionSelector, int index, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
            where TParent : TSqlFragment
            where TChild : TSqlFragment
        {
            // Build an expression to invoke the child expression from within the context of the parent expression
            child(parent).ToExpression(context, false, out _, out sqlType, out cacheKey);
            var details = _intermediateCache.GetOrAdd(cacheKey, __ =>
            {
                var converted = child(parent).ToExpression(context, true, out var parameters, out _, out _);
                return new IntermediateExpression(converted, parameters);
            });

            if (!createExpression || exprParam == null)
                return details.Converted;

            var subExpr = Expression.Invoke(subExpressionSelector, Expression.Convert(exprParam, typeof(TParent)), Expression.Constant(index));

            return Expression.Invoke(details.Lambda, contextParam, subExpr);
        }

        private static Expression ToExpression(ColumnReferenceExpression col, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            var name = col.GetColumnName();

            if (context.Schema == null || !context.Schema.ContainsColumn(name, out var normalizedName))
            {
                if (context.Schema == null || !context.Schema.Aliases.TryGetValue(name, out var normalized))
                {
                    if (context.NonAggregateSchema != null && context.NonAggregateSchema.ContainsColumn(name, out var nonAggregateName))
                        throw new NotSupportedQueryFragmentException(Sql4CdsError.NonAggregateColumnReference(col));

                    var ex = new NotSupportedQueryFragmentException(Sql4CdsError.InvalidColumnName(col));

                    if (col.MultiPartIdentifier.Identifiers.Count == 1 && col.MultiPartIdentifier.Identifiers[0].QuoteType == QuoteType.DoubleQuote)
                        ex.Suggestion = $"Did you mean '{name}'?";
                    else if (name.Equals("false", StringComparison.OrdinalIgnoreCase))
                        ex.Suggestion = "Did you mean '0'?";
                    else if (name.Equals("true", StringComparison.OrdinalIgnoreCase))
                        ex.Suggestion = "Did you mean '1'?";

                    throw ex;
                }

                throw new NotSupportedQueryFragmentException(Sql4CdsError.AmbiguousColumnName(col))
                {
                    Suggestion = $"Did you mean:\r\n{String.Join("\r\n", normalized.Select(c => $"* {c}"))}"
                };
            }

            // Update the column reference to use the normalized name
            if (name != normalizedName)
            {
                var normalizedCol = normalizedName.ToColumnReference();
                col.MultiPartIdentifier.Identifiers.Clear();

                foreach (var part in normalizedCol.MultiPartIdentifier.Identifiers)
                    col.MultiPartIdentifier.Identifiers.Add(part);
            }

            sqlType = context.Schema.Schema[normalizedName].Type;
            var returnType = sqlType.ToNetType(out _);
            cacheKey = $"({returnType})<ColumnReference>";

            if (!createExpression)
                return null;

            var entity = Expression.Property(contextParam, nameof(ExpressionExecutionContext.Entity));
            var attr = Expr.Call(
                () => GetColumnName(Expr.Arg<ColumnReferenceExpression>()),
                Expression.Convert(exprParam, typeof(ColumnReferenceExpression)));
            var expr = Expression.Property(entity, typeof(Entity).GetCustomAttribute<DefaultMemberAttribute>().MemberName, attr);
            return Expression.Convert(expr, returnType);
        }

        private static Expression ToExpression(IdentifierLiteral guid, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            sqlType = DataTypeHelpers.UniqueIdentifier;
            cacheKey = "<GuidLiteral>";

            if (!createExpression)
                return null;

            return Expr.Call(
                () => SqlGuid.Parse(Expr.Arg<string>()),
                Expression.Property(Expression.Convert(exprParam, typeof(IdentifierLiteral)), nameof(IdentifierLiteral.Value)));
        }

        private static Expression ToExpression(IntegerLiteral i, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            sqlType = DataTypeHelpers.Int;
            cacheKey = "<IntLiteral>";

            if (!createExpression)
                return null;

            return Expr.Call(
                () => SqlInt32.Parse(Expr.Arg<string>()),
                Expression.Property(Expression.Convert(exprParam, typeof(IntegerLiteral)), nameof(IntegerLiteral.Value)));
        }

        private static Expression ToExpression(MoneyLiteral money, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            sqlType = DataTypeHelpers.Money;
            cacheKey = "<MoneyLiteral>";

            if (!createExpression)
                return null;

            return Expr.Call(
                () => SqlMoney.Parse(Expr.Arg<string>()),
                Expression.Property(Expression.Convert(exprParam, typeof(MoneyLiteral)), nameof(MoneyLiteral.Value)));
        }

        private static Expression ToExpression(NullLiteral n, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            sqlType = DataTypeHelpers.ImplicitIntForNullLiteral;
            cacheKey = "<NullLiteral>";

            if (!createExpression)
                return null;

            return Expression.Constant(SqlInt32.Null);
        }

        private static Expression ToExpression(NumericLiteral num, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            // The type of the expression varies depending on the precision & scale implicit in the value
            // We need to parse the individual value now to determine the SQL type, but can still return a generic
            // method that can be reused for all values as the actual .NET type is the same
            var value = SqlDecimal.Parse(num.Value);
            sqlType = DataTypeHelpers.Decimal(value.Precision, value.Scale);
            cacheKey = $"<DecimalLiteral({value.Precision},{value.Scale})>";

            if (!createExpression)
                return null;

            return Expr.Call(
                () => SqlDecimal.Parse(Expr.Arg<string>()),
                Expression.Property(Expression.Convert(exprParam, typeof(NumericLiteral)), nameof(NumericLiteral.Value)));
        }

        private static Expression ToExpression(RealLiteral real, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            sqlType = DataTypeHelpers.Real;
            cacheKey = "<RealLiteral>";

            if (!createExpression)
                return null;

            return Expr.Call(
                () => SqlDouble.Parse(Expr.Arg<string>()),
                Expression.Property(Expression.Convert(exprParam, typeof(RealLiteral)), nameof(RealLiteral.Value)));
        }

        private static Expression ToExpression(StringLiteral str, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            // The type of the expression varies depending on whether the string is identified as unicode or not, and the length
            // We can still return a generic method that can be reused for all values as the actual .NET type is the same
            sqlType = str.IsNational
                ? DataTypeHelpers.NVarChar(str.Value.Length, context.PrimaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault)
                : DataTypeHelpers.VarChar(str.Value.Length, context.PrimaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault);

            cacheKey = "<StringLiteral>";

            if (!createExpression)
                return null;

            var value = Expression.Property(Expression.Convert(exprParam, typeof(StringLiteral)), nameof(StringLiteral.Value));

            var expr = (Expression) Expression.Property(contextParam, nameof(ExpressionExecutionContext.PrimaryDataSource));
            expr = Expression.Property(expr, nameof(DataSource.DefaultCollation));
            expr = Expression.Call(expr, nameof(Collation.ToSqlString), Array.Empty<Type>(), value);
            return expr;
        }

        private static Expression ToExpression(OdbcLiteral odbc, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            switch (odbc.OdbcLiteralType)
            {
                case OdbcLiteralType.Date:
                    sqlType = DataTypeHelpers.Date;
                    cacheKey = "<OdbcDateLiteral>";

                    if (!createExpression)
                        return null;

                    var dateExpr = Expr.Call(
                        () => DateTime.ParseExact(Expr.Arg<string>(), Expr.Arg<string>(), Expr.Arg<CultureInfo>(), Expr.Arg<DateTimeStyles>()),
                        Expression.Property(Expression.Convert(exprParam, typeof(OdbcLiteral)), nameof(OdbcLiteral.Value)),
                        Expression.Constant("yyyy'-'MM'-'dd"),
                        Expression.Constant(CultureInfo.InvariantCulture),
                        Expression.Constant(DateTimeStyles.None));

                    return Expression.Convert(dateExpr, typeof(SqlDateTime));

                case OdbcLiteralType.Timestamp:
                    sqlType = DataTypeHelpers.DateTime;
                    cacheKey = "<OdbcDateTimeLiteral>";

                    if (!createExpression)
                        return null;

                    var dateTimeExpr = Expr.Call(
                        () => DateTime.ParseExact(Expr.Arg<string>(), Expr.Arg<string>(), Expr.Arg<CultureInfo>(), Expr.Arg<DateTimeStyles>()),
                        Expression.Property(Expression.Convert(exprParam, typeof(OdbcLiteral)), nameof(OdbcLiteral.Value)),
                        Expression.Constant("yyyy'-'MM'-'dd HH':'mm':'ss"),
                        Expression.Constant(CultureInfo.InvariantCulture),
                        Expression.Constant(DateTimeStyles.None));

                    return Expression.Convert(dateTimeExpr, typeof(SqlDateTime));

                case OdbcLiteralType.Guid:
                    sqlType = DataTypeHelpers.UniqueIdentifier;
                    cacheKey = "<OdbcGuidLiteral>";

                    if (!createExpression)
                        return null;

                    return Expr.Call(
                        () => SqlGuid.Parse(Expr.Arg<string>()),
                        Expression.Property(Expression.Convert(exprParam, typeof(OdbcLiteral)), nameof(OdbcLiteral.Value)));

                default:
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.SyntaxError(odbc)) { Suggestion = "Unknown literal type" };
            }
        }

        private static Expression ToExpression(BooleanComparisonExpression cmp, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            // Special case for field = func() where func is defined in FetchXmlConditionMethods
            if (cmp.FirstExpression is ColumnReferenceExpression &&
                cmp.ComparisonType == BooleanComparisonType.Equals &&
                cmp.SecondExpression is FunctionCall func
                )
            {
                var parameters = func.Parameters.Select((p, index) =>
                {
                    var paramExpr = func.InvokeSubExpression(x => x.Parameters[index], (x, i) => x.Parameters[i], index, context, contextParam, exprParam, createExpression, out var paramType, out var paramCacheKey);
                    return new { Expression = paramExpr, Type = paramType, CacheKey = paramCacheKey };
                }).ToList();
                var colExpr = cmp.InvokeSubExpression(x => x.FirstExpression, x => x.FirstExpression, context, contextParam, exprParam, createExpression, out var colType, out var colCacheKey);
                parameters.Insert(0, new { Expression = colExpr, Type = colType, CacheKey = colCacheKey });
                var paramTypes = parameters.Select(p => p.Type).ToArray();
                var paramCacheKeys = parameters.Select(p => p.CacheKey).ToArray();
                var paramExpressions = parameters.Select(p => p.Expression).ToArray();

                var fetchXmlComparison = GetMethod(context, typeof(FetchXmlConditionMethods), context.PrimaryDataSource, func, paramTypes, paramCacheKeys, false, contextParam, createExpression, ref paramExpressions, out sqlType, out var funcCacheKey);

                if (fetchXmlComparison != null)
                {
                    cacheKey = $"{colCacheKey} = FetchXml::{funcCacheKey}";
                    return createExpression ? Expr.Call(fetchXmlComparison, paramExpressions) : null;
                }
            }

            sqlType = DataTypeHelpers.Bit;

            var lhs = cmp.InvokeSubExpression(x => x.FirstExpression, x => x.FirstExpression, context, contextParam, exprParam, createExpression, out var lhsType, out var lhsCacheKey);
            var rhs = cmp.InvokeSubExpression(x => x.SecondExpression, x => x.SecondExpression, context, contextParam, exprParam, createExpression, out var rhsType, out var rhsCacheKey);

            var operation = Regex.Replace(cmp.ComparisonType.ToString(), "[a-z][A-Z]", m => (m.Value[0] + " " + m.Value[1]).ToLowerInvariant());

            if (!SqlTypeConverter.CanMakeConsistentTypes(lhsType, rhsType, context.PrimaryDataSource, cmp, operation, out var type))
            {
                // Special case - we can filter on entity reference types by string
                if (lhs.Type == typeof(SqlEntityReference) && rhs.Type == typeof(SqlString) ||
                    lhs.Type == typeof(SqlString) && rhs.Type == typeof(SqlEntityReference))
                {
                    type = DataTypeHelpers.UniqueIdentifier;
                }
                else
                {
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(cmp, lhsType, rhsType));
                }
            }

            if (!lhsType.IsSameAs(type))
                lhs = createExpression ? SqlTypeConverter.Convert(lhs, lhsType, type) : null;

            if (!rhsType.IsSameAs(type))
            {
                // Special case to give more helpful & earlier error reporting for common problems
                if (cmp.FirstExpression is ColumnReferenceExpression col &&
                    cmp.SecondExpression is StringLiteral str &&
                    (
                        type.IsType(SqlDataTypeOption.Int) && !Int32.TryParse(str.Value, out _)
                        ||
                        type.IsType(SqlDataTypeOption.UniqueIdentifier) && !Guid.TryParse(str.Value, out _)
                    ) &&
                    context.Schema.ContainsColumn(col.GetColumnName() + "name", out var nameCol))
                {
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.ConversionFailed(rhsType, str, type))
                    {
                        Suggestion = $"Did you mean to filter on the {nameCol} column instead?\r\n" + new string(' ', 26 + nameCol.Length) + "^^^^"
                    };
                }

                rhs = createExpression ? SqlTypeConverter.Convert(rhs, rhsType, type) : null;
            }

            AssertCollationSensitive(type);

            switch (cmp.ComparisonType)
            {
                case BooleanComparisonType.Equals:
                    cacheKey = lhsCacheKey + " = " + rhsCacheKey;
                    return createExpression ? Expression.Equal(lhs, rhs) : null;

                case BooleanComparisonType.GreaterThan:
                    cacheKey = lhsCacheKey + " > " + rhsCacheKey;
                    return createExpression ? Expression.GreaterThan(lhs, rhs) : null;

                case BooleanComparisonType.GreaterThanOrEqualTo:
                case BooleanComparisonType.NotLessThan:
                    cacheKey = lhsCacheKey + " >= " + rhsCacheKey;
                    return createExpression ? Expression.GreaterThanOrEqual(lhs, rhs) : null;

                case BooleanComparisonType.LessThan:
                    cacheKey = lhsCacheKey + " < " + rhsCacheKey;
                    return createExpression ? Expression.LessThan(lhs, rhs) : null;

                case BooleanComparisonType.LessThanOrEqualTo:
                case BooleanComparisonType.NotGreaterThan:
                    cacheKey = lhsCacheKey + " <= " + rhsCacheKey;
                    return createExpression ? Expression.LessThanOrEqual(lhs, rhs) : null;

                case BooleanComparisonType.NotEqualToBrackets:
                case BooleanComparisonType.NotEqualToExclamation:
                    cacheKey = lhsCacheKey + " <> " + rhsCacheKey;
                    return createExpression ? Expression.NotEqual(lhs, rhs) : null;

                default:
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.SyntaxError(cmp)) { Suggestion = "Unknown comparison type" };
            }
        }

        private static Expression ToExpression(DistinctPredicate distinct, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            sqlType = DataTypeHelpers.Bit;

            var lhs = distinct.InvokeSubExpression(x => x.FirstExpression, x => x.FirstExpression, context, contextParam, exprParam, createExpression, out var lhsType, out var lhsCacheKey);
            var rhs = distinct.InvokeSubExpression(x => x.SecondExpression, x => x.SecondExpression, context, contextParam, exprParam, createExpression, out var rhsType, out var rhsCacheKey);

            if (!SqlTypeConverter.CanMakeConsistentTypes(lhsType, rhsType, context.PrimaryDataSource, distinct, distinct.IsNot ? "is not distinct from" : "is distinct from", out var type))
            {
                // Special case - we can filter on entity reference types by string
                if (lhs.Type == typeof(SqlEntityReference) && rhs.Type == typeof(SqlString) ||
                    lhs.Type == typeof(SqlString) && rhs.Type == typeof(SqlEntityReference))
                {
                    type = DataTypeHelpers.UniqueIdentifier;
                }
                else
                {
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(distinct, lhsType, rhsType));
                }
            }

            if (!lhsType.IsSameAs(type))
                lhs = createExpression ? SqlTypeConverter.Convert(lhs, lhsType, type) : null;

            if (!rhsType.IsSameAs(type))
            {
                // Special case to give more helpful & earlier error reporting for common problems
                if (distinct.FirstExpression is ColumnReferenceExpression col &&
                    distinct.SecondExpression is StringLiteral str &&
                    (
                        type.IsType(SqlDataTypeOption.Int) && !Int32.TryParse(str.Value, out _)
                        ||
                        type.IsType(SqlDataTypeOption.UniqueIdentifier) && !Guid.TryParse(str.Value, out _)
                    ) &&
                    context.Schema.ContainsColumn(col.GetColumnName() + "name", out var nameCol))
                {
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.ConversionFailed(rhsType, str, type))
                    {
                        Suggestion = $"Did you mean to filter on the {nameCol} column instead?\r\n" + new string(' ', 26 + nameCol.Length) + "^^^^"
                    };
                }

                rhs = createExpression ? SqlTypeConverter.Convert(rhs, rhsType, type) : null;
            }

            AssertCollationSensitive(type);

            // Using linked server decoding pseudocode from https://learn.microsoft.com/en-us/sql/t-sql/queries/is-distinct-from-transact-sql?view=sql-server-ver16#remarks
            var expr = createExpression
                ? (Expression) Expression.AndAlso(
                Expression.OrElse(
                    Expression.OrElse(
                        SqlTypeConverter.NullCheck(rhs),
                        SqlTypeConverter.NullCheck(lhs)
                        ),
                    Expression.IsTrue(Expression.NotEqual(lhs, rhs))
                    ),
                Expression.Not(
                    Expression.AndAlso(
                        SqlTypeConverter.NullCheck(lhs),
                        SqlTypeConverter.NullCheck(rhs)
                        )
                    )
                )
                : null;

            if (distinct.IsNot)
            {
                cacheKey = lhsCacheKey + " IS NOT DISTINCT FROM " + rhsCacheKey;
                expr = createExpression ? Expression.Not(expr) : null;
            }
            else
            {
                cacheKey = lhsCacheKey + " IS DISTINCT FROM " + rhsCacheKey;
            }

            return expr;
        }

        private static Expression ToExpression(BooleanBinaryExpression bin, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            sqlType = DataTypeHelpers.Bit;

            var lhs = bin.InvokeSubExpression(x => x.FirstExpression, x => x.FirstExpression, context, contextParam, exprParam, createExpression, out _, out var lhsCacheKey);
            var rhs = bin.InvokeSubExpression(x => x.SecondExpression, x => x.SecondExpression, context, contextParam, exprParam, createExpression, out _, out var rhsCacheKey);

            if (bin.BinaryExpressionType == BooleanBinaryExpressionType.And)
            {
                cacheKey = lhsCacheKey + " AND " + rhsCacheKey;
                return createExpression ? Expression.AndAlso(lhs, rhs) : null;
            }

            cacheKey = lhsCacheKey + " OR " + rhsCacheKey;
            return createExpression ? Expression.OrElse(lhs, rhs) : null;
        }

        private static Expression ToExpression(BooleanParenthesisExpression paren, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            var expr = paren.InvokeSubExpression(x => x.Expression, x => x.Expression, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            cacheKey = "(" + cacheKey + ")";
            return expr;
        }

        private static Expression ToExpression(Microsoft.SqlServer.TransactSql.ScriptDom.BinaryExpression bin, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            var lhs = bin.InvokeSubExpression(x => x.FirstExpression, x => x.FirstExpression, context, contextParam, exprParam, true, out var lhsSqlType, out var lhsCacheKey);
            var rhs = bin.InvokeSubExpression(x => x.SecondExpression, x => x.SecondExpression, context, contextParam, exprParam, true, out var rhsSqlType, out var rhsCacheKey);

            if (!SqlTypeConverter.CanMakeConsistentTypes(lhsSqlType, rhsSqlType, context.PrimaryDataSource, bin, bin.BinaryExpressionType.ToString().ToLowerInvariant(), out var type))
                throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(bin, lhsSqlType, rhsSqlType));

            // For decimal types, need to work out the precision and scale of the result depending on the type of operation
            if (type is SqlDataTypeReference sqlTargetType && (sqlTargetType.SqlDataTypeOption == SqlDataTypeOption.Numeric || sqlTargetType.SqlDataTypeOption == SqlDataTypeOption.Decimal))
            {
                var p1 = lhsSqlType.GetPrecision();
                var s1 = lhsSqlType.GetScale();
                var p2 = rhsSqlType.GetPrecision();
                var s2 = rhsSqlType.GetScale();

                var p = type.GetPrecision();
                var s = type.GetScale();

                switch (bin.BinaryExpressionType)
                {
                    case BinaryExpressionType.Add:
                    case BinaryExpressionType.Subtract:
                        p = (short)(Math.Max(s1, s2) + Math.Max(p1 - s1, p2 - s2) + 1);
                        s = Math.Max(s1, s2);
                        break;

                    case BinaryExpressionType.Multiply:
                        p = (short)(p1 + p2 + 1);
                        s = (short)(s1 + s2);
                        break;

                    case BinaryExpressionType.Divide:
                        p = (short)(p1 - s1 + s2 + Math.Max(6, s1 + p2 + 1));
                        s = (short)(Math.Max(6, s1 + p2 + 1));
                        break;
                }

                if (p > 38)
                {
                    switch (bin.BinaryExpressionType)
                    {
                        case BinaryExpressionType.Add:
                        case BinaryExpressionType.Subtract:
                            p = 38;
                            s = (short)(p - Math.Max(p1 - s1, p2 - s2));
                            break;

                        case BinaryExpressionType.Multiply:
                        case BinaryExpressionType.Divide:
                            if ((p - s) < 32)
                                s = (short)(Math.Min(s, 38 - (p - s)));
                            else if (s > 6 && (p - s) > 32)
                                s = 6;

                            if (p > 38)
                                p = 38;
                            break;
                    }
                }

                type = DataTypeHelpers.Decimal(p, s);

                if (lhs.Type != typeof(SqlDecimal))
                    lhs = SqlTypeConverter.Convert(lhs, lhsSqlType, DataTypeHelpers.Decimal(lhsSqlType.GetPrecision(), lhsSqlType.GetScale()));
                if (rhs.Type != typeof(SqlDecimal))
                    rhs = SqlTypeConverter.Convert(rhs, rhsSqlType, DataTypeHelpers.Decimal(rhsSqlType.GetPrecision(), rhsSqlType.GetScale()));
            }
            else
            {
                if (!lhsSqlType.IsSameAs(type))
                    lhs = SqlTypeConverter.Convert(lhs, lhsSqlType, type);

                if (!rhsSqlType.IsSameAs(type))
                    rhs = SqlTypeConverter.Convert(rhs, rhsSqlType, type);
            }

            sqlType = null;
            Expression expr;

            switch (bin.BinaryExpressionType)
            {
                case BinaryExpressionType.Add:
                    cacheKey = lhsCacheKey + " + " + rhsCacheKey;

                    // Special case for SqlDateTime
                    if (lhs.Type == typeof(SqlDateTime) && rhs.Type == typeof(SqlDateTime))
                        expr = Expr.Call(() => AddSqlDateTime(Expr.Arg<SqlDateTime>(), Expr.Arg<SqlDateTime>()), lhs, rhs);
                    else
                        expr = Expression.Add(lhs, rhs);

                    // Special case for SqlString length & collation calculation
                    if (lhsSqlType is SqlDataTypeReferenceWithCollation lhsSql &&
                        rhsSqlType is SqlDataTypeReferenceWithCollation rhsSql &&
                        lhsSql.Parameters.Count == 1 &&
                        rhsSql.Parameters.Count == 1)
                    {
                        int lhsLength;
                        int rhsLength;

                        if (lhsSql.Parameters[0].LiteralType != LiteralType.Integer ||
                            !Int32.TryParse(lhsSql.Parameters[0].Value, out lhsLength))
                            lhsLength = 8000;

                        if (rhsSql.Parameters[0].LiteralType != LiteralType.Integer ||
                            !Int32.TryParse(rhsSql.Parameters[0].Value, out rhsLength))
                            rhsLength = 8000;

                        var length = lhsLength + rhsLength;

                        if (!SqlDataTypeReferenceWithCollation.TryConvertCollation(lhsSql, rhsSql, bin, "add", out var collation, out var collationLabel, out var collationError))
                            throw new NotSupportedQueryFragmentException(collationError);

                        sqlType = new SqlDataTypeReferenceWithCollation
                        {
                            SqlDataTypeOption = ((SqlDataTypeReference)type).SqlDataTypeOption,
                            Parameters = { length <= 8000 ? (Literal)new IntegerLiteral { Value = length.ToString(CultureInfo.InvariantCulture) } : new MaxLiteral() },
                            Collation = collation,
                            CollationLabel = collationLabel,
                            CollationConflictError = collationError
                        };
                    }
                    break;

                case BinaryExpressionType.Subtract:
                    cacheKey = lhsCacheKey + " - " + rhsCacheKey;

                    // Special case for SqlDateTime
                    if (lhs.Type == typeof(SqlDateTime) && rhs.Type == typeof(SqlDateTime))
                        expr = Expr.Call(() => SubtractSqlDateTime(Expr.Arg<SqlDateTime>(), Expr.Arg<SqlDateTime>()), lhs, rhs);
                    else
                        expr = Expression.Subtract(lhs, rhs);
                    break;

                case BinaryExpressionType.Multiply:
                    cacheKey = lhsCacheKey + " * " + rhsCacheKey;
                    expr = Expression.Multiply(lhs, rhs);
                    break;

                case BinaryExpressionType.Divide:
                    cacheKey = lhsCacheKey + " / " + rhsCacheKey;
                    expr = Expression.Divide(lhs, rhs);

                    expr = Expression.TryCatch(expr, Expression.Catch(typeof(DivideByZeroException), Expression.Throw(Expression.New(typeof(QueryExecutionException).GetConstructor(new[] { typeof(Sql4CdsError) }), Expr.Call(() => Sql4CdsError.DivideByZero())), expr.Type)));
                    break;

                case BinaryExpressionType.Modulo:
                    cacheKey = lhsCacheKey + " % " + rhsCacheKey;
                    expr = Expression.Modulo(lhs, rhs);
                    break;

                case BinaryExpressionType.BitwiseAnd:
                    cacheKey = lhsCacheKey + " & " + rhsCacheKey;
                    expr = Expression.And(lhs, rhs);
                    break;

                case BinaryExpressionType.BitwiseOr:
                    cacheKey = lhsCacheKey + " | " + rhsCacheKey;
                    expr = Expression.Or(lhs, rhs);
                    break;

                case BinaryExpressionType.BitwiseXor:
                    cacheKey = lhsCacheKey + " ^ " + rhsCacheKey;
                    expr = Expression.ExclusiveOr(lhs, rhs);
                    break;

                default:
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.SyntaxError(bin)) { Suggestion = "Unknown operator" };
            }

            if (sqlType == null && expr.Type == typeof(SqlDecimal))
                sqlType = type;

            if (sqlType == null)
                sqlType = expr.Type.ToSqlType(context.PrimaryDataSource);

            return expr;
        }

        private static SqlDateTime AddSqlDateTime(SqlDateTime lhs, SqlDateTime rhs)
        {
            if (lhs.IsNull || rhs.IsNull)
                return SqlDateTime.Null;

            // Convert the second value to the TimeSpan difference between 1900-01-01 and the given value first
            var ts = rhs.Value - new DateTime(1900, 1, 1);
            return lhs + ts;
        }

        private static SqlDateTime SubtractSqlDateTime(SqlDateTime lhs, SqlDateTime rhs)
        {
            if (lhs.IsNull || rhs.IsNull)
                return SqlDateTime.Null;

            // Convert the second value to the TimeSpan difference between 1900-01-01 and the given value first
            var ts = rhs.Value - new DateTime(1900, 1, 1);
            return lhs - ts;
        }

        private static MethodInfo GetMethod(FunctionCall func, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out Expression[] paramExpressions, out DataTypeReference sqlType, out string cacheKey)
        {
            var paramExpressionsWithType = func.Parameters
                .Select((param, index) =>
                {
                    // Special case for DATEPART / DATEDIFF / DATEADD - first parameter looks like a field but is actually an identifier
                    if (index == 0 &&
                        (
                            func.FunctionName.Value.Equals("DATEPART", StringComparison.OrdinalIgnoreCase) ||
                            func.FunctionName.Value.Equals("DATEDIFF", StringComparison.OrdinalIgnoreCase) ||
                            func.FunctionName.Value.Equals("DATEADD", StringComparison.OrdinalIgnoreCase)
                        ))
                    {
                        // Check parameter is an expected datepart value
                        if (!(param is ColumnReferenceExpression col) || col.MultiPartIdentifier.Identifiers.Count != 1)
                            throw new NotSupportedQueryFragmentException(Sql4CdsError.InvalidParameter(param, 1, "datepart"));

                        try
                        {
                            ExpressionFunctions.DatePartToInterval(col.MultiPartIdentifier.Identifiers.Single().Value);
                        }
                        catch
                        {
                            throw new NotSupportedQueryFragmentException(Sql4CdsError.InvalidOptionValue(param, "datepart"));
                        }

                        return new { Expression = createExpression ? (Expression)Expression.Constant(col.MultiPartIdentifier.Identifiers.Single().Value) : null, Type = (DataTypeReference)DataTypeHelpers.NVarChar(col.MultiPartIdentifier.Identifiers.Single().Value.Length, context.PrimaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault), CacheKey = col.MultiPartIdentifier.Identifiers.Single().Value };
                    }

                    // Special case for ISJSON - second optional parameter looks like a field but is actually a JSON data type
                    if (index == 1 && func.FunctionName.Value.Equals("ISJSON", StringComparison.OrdinalIgnoreCase))
                    {
                        // Check parameter is an expected datepart value
                        if (!(param is ColumnReferenceExpression col) || col.MultiPartIdentifier.Identifiers.Count != 1)
                            throw new NotSupportedQueryFragmentException(Sql4CdsError.InvalidParameter(param, 2, "isjson"));

                        switch (col.MultiPartIdentifier.Identifiers.Single().Value.ToLowerInvariant())
                        {
                            case "value":
                            case "array":
                            case "object":
                            case "scalar":
                                break;

                            default:
                               throw new NotSupportedQueryFragmentException(Sql4CdsError.InvalidOptionValue(param, "isjson"));
                        }

                        return new { Expression = createExpression ? (Expression)Expression.Constant(col.MultiPartIdentifier.Identifiers.Single().Value) : null, Type = (DataTypeReference)DataTypeHelpers.NVarChar(col.MultiPartIdentifier.Identifiers.Single().Value.Length, context.PrimaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault), CacheKey = col.MultiPartIdentifier.Identifiers.Single().Value };
                    }
                    
                    var paramExpr = func.InvokeSubExpression(x => x.Parameters[index], (x, i) => x.Parameters[i], index, context, contextParam, exprParam, createExpression, out var paramType, out var paramCacheKey);
                    return new { Expression = paramExpr, Type = paramType, CacheKey = paramCacheKey };
                })
                .ToList();

            if (func.CallTarget != null)
            {
                // If this function has a target (e.g. xml functions), add the target as the first parameter
                var targetParam = func.InvokeSubExpression(x => x.CallTarget, x => x.CallTarget, context, contextParam, exprParam, createExpression, out var targetType, out var targetCacheKey);
                paramExpressionsWithType.Insert(0, new { Expression = targetParam, Type = targetType, CacheKey = targetCacheKey });
            }

            paramExpressions = paramExpressionsWithType
                .Select(kvp => kvp.Expression)
                .ToArray();

            return GetMethod(context, typeof(ExpressionFunctions), context.PrimaryDataSource, func, paramExpressionsWithType.Select(kvp => kvp.Type).ToArray(), paramExpressionsWithType.Select(kvp => kvp.CacheKey).ToArray(), true, contextParam, createExpression, ref paramExpressions, out sqlType, out cacheKey);
        }

        private static MethodInfo GetMethod(ExpressionCompilationContext context, Type targetType, DataSource primaryDataSource, FunctionCall func, DataTypeReference[] paramTypes, string[] paramCacheKeys, bool throwOnMissing, ParameterExpression contextParam, bool createExpression, ref Expression[] paramExpressions, out DataTypeReference sqlType, out string cacheKey)
        {
            // Find a method that implements this function
            var methods = targetType
                .GetMethods(BindingFlags.InvokeMethod | BindingFlags.Public | BindingFlags.Static)
                .Where(m => m.Name.Equals(func.FunctionName.Value, StringComparison.OrdinalIgnoreCase))
                .ToList();

            if (methods.Count == 0)
            {
                if (throwOnMissing)
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.InvalidFunction(func.FunctionName));

                cacheKey = null;
                sqlType = DataTypeHelpers.Int;
                return null;
            }

            // Check parameter count is correct
            var correctParameterCount = methods
                .Select(m => new { Method = m, Parameters = m.GetParameters() })
                .Where(m =>
                {
                    var allowedParameters = m.Parameters.Where(p => p.GetCustomAttribute<SourceTypeAttribute>() == null && p.ParameterType != typeof(ExpressionExecutionContext) && p.ParameterType != typeof(INodeSchema));
                    var requiredParameters = allowedParameters.Where(p => p.GetCustomAttribute<OptionalAttribute>() == null);
                    var isArrayParameter = requiredParameters.Any() && requiredParameters.Last().ParameterType.IsArray;

                    if (paramTypes.Length < requiredParameters.Count())
                        return false;

                    if (paramTypes.Length > allowedParameters.Count() && !isArrayParameter)
                        return false;

                    return true;
                })
                .ToList();

            if (correctParameterCount.Count == 0)
                throw new NotSupportedQueryFragmentException(Sql4CdsError.InvalidFunctionParameterCount(func.FunctionName, methods[0].GetParameters().Length));

            if (correctParameterCount.Count > 1)
                throw new NotSupportedQueryFragmentException("Ambiguous method", func);

            var method = correctParameterCount[0].Method;
            var parameters = correctParameterCount[0].Parameters;
            DataTypeReference sourceType = null;
            cacheKey = method.Name;

            if (correctParameterCount[0].Method.IsGenericMethodDefinition)
            {
                // Create the generic method based on the type of the generic arguments
                var genericArguments = correctParameterCount[0].Method.GetGenericArguments();
                var genericArgumentValues = new Type[genericArguments.Length];

                foreach (var param in correctParameterCount[0].Parameters)
                {
                    for (var i = 0; i < genericArguments.Length; i++)
                    {
                        if (param.ParameterType == genericArguments[i] && genericArgumentValues[i] == null)
                        {
                            genericArgumentValues[i] = paramTypes[i].ToNetType(out _);
                            sourceType = paramTypes[i];
                        }
                    }
                }

                cacheKey += "<" + String.Join(",", genericArgumentValues.Select(t => t.FullName)) + ">";

                method = method.MakeGenericMethod(genericArgumentValues);
                parameters = method.GetParameters();
            }

            cacheKey += "(" + String.Join(",", paramCacheKeys) + ")";

            sqlType = null;

            if (method.ReturnType == typeof(SqlString))
            {
                // Use the [MaxLength(value)] attribute from the method where available
                var methodMaxLength = method.GetCustomAttribute<MaxLengthAttribute>();

                if (methodMaxLength?.MaxLength != null)
                    sqlType = DataTypeHelpers.NVarChar(methodMaxLength.MaxLength.Value, primaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault);

                // Work out precise type from parameter with [MaxLength] attribute where available
                for (var i = 0; i < parameters.Length; i++)
                {
                    if (parameters[i].GetCustomAttribute<MaxLengthAttribute>() != null)
                    {
                        if (parameters[i].ParameterType == typeof(SqlInt32) && func.Parameters[i] is IntegerLiteral lengthConst)
                            sqlType = DataTypeHelpers.NVarChar(SqlInt32.Parse(lengthConst.Value).Value, primaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault);
                        else if (parameters[i].ParameterType == typeof(SqlString) && paramTypes[i].ToNetType(out var sqlStringType) == typeof(SqlString))
                            sqlType = paramTypes[i];

                        break;
                    }
                }
            }

            // Check parameter types can be converted
            var paramOffset = targetType == typeof(FetchXmlConditionMethods) ? 1 : 0;
            var hiddenParams = 0;

            for (var i = 0; i < parameters.Length; i++)
            {
                if (i > 0)
                    cacheKey += ", ";

                var paramType = parameters[i].ParameterType;

                if (i == parameters.Length - 1 && paramTypes.Length >= parameters.Length - hiddenParams && paramType.IsArray)
                    paramType = paramType.GetElementType();

                var paramIndex = i;

                if (func.CallTarget != null)
                    paramIndex--;

                if (paramType == typeof(ExpressionExecutionContext))
                {
                    if (createExpression)
                    {
                        var paramsWithOptions = new List<Expression>(paramExpressions);
                        paramsWithOptions.Insert(i, contextParam);
                        paramExpressions = paramsWithOptions.ToArray();
                    }
                    hiddenParams++;
                    continue;
                }

                if (paramType == typeof(INodeSchema))
                {
                    if (createExpression)
                    {
                        var paramsWithOptions = new List<Expression>(paramExpressions);
                        paramsWithOptions.Insert(i, Expression.Constant(context.Schema));
                        paramExpressions = paramsWithOptions.ToArray();
                    }
                    hiddenParams++;
                    continue;
                }

                if (i >= paramTypes.Length && parameters[i].GetCustomAttribute<OptionalAttribute>() != null)
                {
                    if (createExpression)
                    {
                        var paramsWithDefaultValue = new Expression[paramExpressions.Length + 1];
                        paramExpressions.CopyTo(paramsWithDefaultValue, 0);
                        paramsWithDefaultValue[i] = Expression.Constant(SqlTypeConverter.GetNullValue(paramType));
                        paramExpressions = paramsWithDefaultValue;
                    }
                    hiddenParams++;
                    continue;
                }

                if (paramType == typeof(DataTypeReference))
                {
                    if (parameters[i].GetCustomAttribute<SourceTypeAttribute>() != null)
                    {
                        cacheKey += $"(TYPE:{sourceType.ToSql()})";
                        if (createExpression)
                        {
                            var paramsWithType = new Expression[paramExpressions.Length + 1];
                            paramExpressions.CopyTo(paramsWithType, 0);
                            paramsWithType[i] = Expression.Constant(sourceType);
                            paramExpressions = paramsWithType;
                        }
                        hiddenParams++;
                    }
                    else
                    {
                        // Expect only a literal string
                        if (!(func.Parameters[paramIndex] is StringLiteral typeLiteral))
                            throw new NotSupportedQueryFragmentException(Sql4CdsError.XmlDataTypeMethodRequiresStringLiteralParameter(func.Parameters[paramIndex], func.FunctionName, i));

                        if (!DataTypeHelpers.TryParse(context, typeLiteral.Value, out var parsedType))
                            throw new NotSupportedQueryFragmentException(Sql4CdsError.InvalidDataTypeForXmlValueMethod(typeLiteral));

                        cacheKey +=$"(TYPE:{parsedType.ToSql()})";

                        if (createExpression)
                            paramExpressions[i] = Expression.Constant(parsedType);

                        if (parameters[i].GetCustomAttribute<TargetTypeAttribute>() != null)
                            sqlType = parsedType;
                    }

                    continue;
                }

                if (paramType == typeof(XPath2Expression))
                {
                    // Expect only a literal string
                    if (!(func.Parameters[paramIndex] is StringLiteral xpathLiteral))
                        throw new NotSupportedQueryFragmentException(Sql4CdsError.XmlDataTypeMethodRequiresStringLiteralParameter(func.Parameters[paramIndex], func.FunctionName, i));

                    cacheKey += $"(XPATH:{xpathLiteral.Value})";

                    if (createExpression)
                        paramExpressions[i] = Expression.Constant(XPath2Expression.Compile(xpathLiteral.Value, XPath2ExpressionContext.XmlNamespaceManager));

                    continue;
                }

                if (paramType != typeof(INullable) && !SqlTypeConverter.CanChangeTypeImplicit(paramTypes[i - hiddenParams], paramType.ToSqlType(primaryDataSource)))
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(i < paramOffset ? func : func.Parameters[i - paramOffset], paramTypes[i], paramType.ToSqlType(primaryDataSource)));
            }

            for (var i = parameters.Length; i < paramTypes.Length; i++)
            {
                var paramType = parameters.Last().ParameterType.GetElementType();

                if (paramType != typeof(INullable) && !SqlTypeConverter.CanChangeTypeImplicit(paramTypes[i], paramType.ToSqlType(primaryDataSource)))
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(i < paramOffset ? func : func.Parameters[i - paramOffset], paramTypes[i], paramType.ToSqlType(primaryDataSource)));
            }

            if (createExpression && parameters.Length > 0 && parameters.Last().ParameterType.IsArray)
            {
                var arrayType = parameters.Last().ParameterType.GetElementType();
                var arrayMembers = new List<Expression>();

                for (var i = parameters.Length - 1; i < paramExpressions.Length; i++)
                {
                    if (arrayType == typeof(INullable))
                        arrayMembers.Add(Expression.Convert(paramExpressions[i], typeof(INullable)));
                    else
                        arrayMembers.Add(SqlTypeConverter.Convert(paramExpressions[i], arrayType));
                }

                var arrayParam = Expression.NewArrayInit(arrayType, arrayMembers);
                paramExpressions = paramExpressions.Take(parameters.Length - 1).Concat(new[] { arrayParam }).ToArray();
            }

            if (sqlType == null)
                sqlType = method.ReturnType.ToSqlType(primaryDataSource);

            if (method.GetCustomAttribute(typeof(CollationSensitiveAttribute)) != null)
            {
                // If method is collation sensitive:
                // 1. check all string parameters can be converted to a consistent collation
                // 2. check the consistent collation label is not no-collation
                // 3. use the same collation for the return type
                SqlDataTypeReferenceWithCollation collation = null;

                foreach (var paramType in paramTypes)
                {
                    if (!(paramType is SqlDataTypeReferenceWithCollation collationParam))
                        continue;

                    if (collation == null)
                    {
                        collation = collationParam;
                        continue;
                    }

                    if (!SqlDataTypeReferenceWithCollation.TryConvertCollation(collation, collationParam, func, func.FunctionName.Value.ToLowerInvariant(), out var consistentCollation, out var collationLabel, out var collationError))
                        throw new NotSupportedQueryFragmentException(collationError);

                    collation = new SqlDataTypeReferenceWithCollation
                    {
                        Collation = consistentCollation,
                        CollationLabel = collationLabel,
                        CollationConflictError = collationError
                    };

                    AssertCollationSensitive(collation);
                }

                if (collation == null)
                {
                    // In case the parameter is null, assume a default collation for the output
                    collation = new SqlDataTypeReferenceWithCollation
                    {
                        Collation = primaryDataSource.DefaultCollation,
                        CollationLabel = CollationLabel.CoercibleDefault
                    };
                }

                for (var i = 0; i < paramTypes.Length; i++)
                {
                    if (!(paramTypes[i] is SqlDataTypeReferenceWithCollation collationParam))
                        continue;

                    if (!collationParam.Collation.Equals(collation.Collation))
                    {
                        // TODO: Ensure same collation isn't reused when cached compiled expression is executed for different collations
                        if (createExpression)
                            paramExpressions[i] = Expr.Call(() => SqlTypeConverter.ConvertCollation(Expr.Arg<SqlString>(), Expr.Arg<Collation>()), paramExpressions[i], Expression.Constant(collation.Collation));

                        paramTypes[i] = new SqlDataTypeReferenceWithCollation
                        {
                            SqlDataTypeOption = collationParam.SqlDataTypeOption,
                            Collation = collation.Collation,
                            CollationLabel = CollationLabel.Explicit
                        };

                        foreach (var param in collationParam.Parameters)
                            ((SqlDataTypeReferenceWithCollation)paramTypes[i]).Parameters.Add(param);
                    }
                }

                if (sqlType is SqlDataTypeReferenceWithCollation outputCollation)
                {
                    outputCollation.Collation = collation.Collation;
                    outputCollation.CollationLabel = collation.CollationLabel;
                }
            }

            return method;
        }

        private static Expression ToExpression(this FunctionCall func, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            if (func.OverClause != null)
                throw new NotSupportedQueryFragmentException(Sql4CdsError.NotSupported(func, "OVER"));

            if (func.WithinGroupClause != null)
                throw new NotSupportedQueryFragmentException(Sql4CdsError.SyntaxError(func)) { Suggestion = $"The function '{func.FunctionName.Value}' may not have a WITHIN GROUP clause" };

            // Special case: ExplicitCollation is a pseudo-function that's introduced by the ExplicitCollationVisitor to wrap
            // primary expressions with a collation definition. The inner expression will already have applied the collation
            // change so we can return it without any further processing
            if (func.FunctionName.Value == "ExplicitCollation" && func.Parameters.Count == 1)
            {
                var converted = func.InvokeSubExpression(x => x.Parameters[0], (x, i) => x.Parameters[i], 0, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);

                if (!(sqlType is SqlDataTypeReferenceWithCollation coll) ||
                    !coll.SqlDataTypeOption.IsStringType() ||
                    coll.Collation == null ||
                    coll.CollationLabel != CollationLabel.Explicit)
                {
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.InvalidFunction(func.FunctionName));
                }

                cacheKey = $"ExplicitCollation({cacheKey})";
                return converted;
            }

            // Find the method to call and get the expressions for the parameter values
            var method = GetMethod(func, context, contextParam, exprParam, createExpression, out var paramValues, out sqlType, out cacheKey);

            if (!createExpression)
                return null;

            // Convert the parameters to the expected types
            var parameters = method.GetParameters();

            for (var i = 0; i < parameters.Length; i++)
            {
                if (paramValues[i].Type != parameters[i].ParameterType)
                    paramValues[i] = SqlTypeConverter.Convert(paramValues[i], parameters[i].ParameterType);
            }

            var expr = (Expression) Expression.Call(method, paramValues);

            if (expr.Type == typeof(object) && parameters.Any(p => p.GetCustomAttribute<TargetTypeAttribute>() != null))
                expr = Expression.Convert(expr, sqlType.ToNetType(out _));

            return expr;
        }

        private static Expression ToExpression(this ParenthesisExpression paren, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            var expr = paren.InvokeSubExpression(x => x.Expression, x => x.Expression, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            cacheKey = "(" + cacheKey + ")";
            return expr;
        }

        private static Expression ToExpression(this ExpressionCallTarget callTarget, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            var expr = callTarget.InvokeSubExpression(x => x.Expression, x => x.Expression, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            cacheKey += "<CallTarget>";
            return expr;
        }

        private static Expression ToExpression(this Microsoft.SqlServer.TransactSql.ScriptDom.UnaryExpression unary, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            var value = unary.InvokeSubExpression(x => x.Expression, x => x.Expression, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            
            switch (unary.UnaryExpressionType)
            {
                case UnaryExpressionType.Positive:
                    cacheKey = "+" + cacheKey;
                    return createExpression ? Expression.UnaryPlus(value) : null;

                case UnaryExpressionType.Negative:
                    cacheKey = "-" + cacheKey;
                    return createExpression ? Expression.Negate(value) : null;

                case UnaryExpressionType.BitwiseNot:
                    cacheKey = "~" + cacheKey;
                    return createExpression ? Expression.Not(value) : null;

                default:
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.SyntaxError(unary)) { Suggestion = "Unknown unary operator" };
            }
        }

        private static Expression ToExpression(this InPredicate inPred, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            if (inPred.Subquery != null)
                throw new NotSupportedQueryFragmentException("Subquery should have been eliminated by query plan", inPred);

            var exprValue = inPred.InvokeSubExpression(x => x.Expression, x => x.Expression, context, contextParam, exprParam, createExpression, out var exprType, out cacheKey);
            if (inPred.NotDefined)
                cacheKey += " NOT IN (";
            else
                cacheKey += " IN (";

            Expression result = null;

            for (var i = 0; i < inPred.Values.Count; i++)
            {
                var comparisonValue = inPred.InvokeSubExpression(x => x.Values[i], (x, j) => x.Values[j], i, context, contextParam, exprParam, createExpression, out var comparisonType, out var comparisonCacheKey);

                if (!SqlTypeConverter.CanMakeConsistentTypes(exprType, comparisonType, context.PrimaryDataSource, inPred, "in", out var type))
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(inPred, exprType, comparisonType));

                if (createExpression)
                {
                    var convertedExprValue = exprValue;

                    if (!exprType.IsSameAs(type))
                        convertedExprValue = SqlTypeConverter.Convert(convertedExprValue, exprType, type);

                    if (!comparisonType.IsSameAs(type))
                        comparisonValue = SqlTypeConverter.Convert(comparisonValue, comparisonType, type);

                    var comparison = inPred.NotDefined ? Expression.NotEqual(convertedExprValue, comparisonValue) : Expression.Equal(convertedExprValue, comparisonValue);

                    if (result == null)
                        result = comparison;
                    else
                        result = inPred.NotDefined ? Expression.AndAlso(result, comparison) : Expression.OrElse(result, comparison);
                }

                if (i > 0)
                    cacheKey += ", ";

                cacheKey += comparisonCacheKey;
            }

            cacheKey += ")";
            sqlType = DataTypeHelpers.Bit;
            return result;
        }

        private static Expression ToExpression(this VariableReference var, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            if (context.ParameterTypes == null || !context.ParameterTypes.TryGetValue(var.Name, out sqlType))
                throw new NotSupportedQueryFragmentException(Sql4CdsError.UndeclaredVariable(var));

            var netType = sqlType.ToNetType(out _);
            cacheKey = $"({netType})<Variable>";

            if (!createExpression)
                return null;

            var parameters = Expression.Property(contextParam, nameof(ExpressionExecutionContext.ParameterValues));
            var varName = Expression.Property(Expression.Convert(exprParam, typeof(VariableReference)), nameof(VariableReference.Name));
            var expr = Expression.Property(parameters, typeof(IDictionary<string, object>).GetCustomAttribute<DefaultMemberAttribute>().MemberName, varName);
            return Expression.Convert(expr, netType);
        }

        private static Expression ToExpression(this GlobalVariableExpression var, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            if (context.ParameterTypes == null || !context.ParameterTypes.TryGetValue(var.Name, out sqlType))
                throw new NotSupportedQueryFragmentException(Sql4CdsError.UndeclaredVariable(var));

            var netType = sqlType.ToNetType(out _);
            cacheKey = $"({netType})<GlobalVariable>";

            if (!createExpression)
                return null;

            var parameters = Expression.Property(contextParam, nameof(ExpressionExecutionContext.ParameterValues));
            var varName = Expression.Property(Expression.Convert(exprParam, typeof(GlobalVariableExpression)), nameof(GlobalVariableExpression.Name));
            var expr = Expression.Property(parameters, typeof(IDictionary<string, object>).GetCustomAttribute<DefaultMemberAttribute>().MemberName, varName);
            return Expression.Convert(expr, netType);
        }

        private static Expression ToExpression(this BooleanIsNullExpression isNull, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            var value = isNull.InvokeSubExpression(x => x.Expression, x => x.Expression, context, contextParam, exprParam, createExpression, out _, out cacheKey);
            value = createExpression ? SqlTypeConverter.NullCheck(value) : null;

            if (isNull.IsNot)
            {
                value = createExpression ? Expression.Not(value) : null;
                cacheKey += " IS NOT NULL";
            }
            else
            {
                cacheKey += " IS NULL";
            }

            value = createExpression ? SqlTypeConverter.Convert(value, typeof(SqlBoolean)) : null;
            sqlType = DataTypeHelpers.Bit;
            return value;
        }

        private static Expression ToExpression(this LikePredicate like, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            DataTypeReference escapeType = null;
            string escapeCacheKey = null;

            var value = like.InvokeSubExpression(x => x.FirstExpression, x => x.FirstExpression, context, contextParam, exprParam, createExpression, out var valueType, out var valueCacheKey);
            var pattern = like.InvokeSubExpression(x => x.SecondExpression, x => x.SecondExpression, context, contextParam, exprParam, createExpression, out var patternType, out var patternCacheKey);
            var escape = like.EscapeExpression == null ? null : like.InvokeSubExpression(x => x.EscapeExpression, x => x.EscapeExpression, context, contextParam, exprParam, createExpression, out escapeType, out escapeCacheKey);

            sqlType = DataTypeHelpers.Bit;
            var stringType = DataTypeHelpers.NVarChar(Int32.MaxValue, context.PrimaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault);

            if (valueType.GetDataTypeFamily() != DataTypeFamily.Character)
            {
                if (!SqlTypeConverter.CanChangeTypeImplicit(valueType, stringType))
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(like.FirstExpression, valueType, stringType));

                value = createExpression ? SqlTypeConverter.Convert(value, valueType, stringType) : null;
                valueType = stringType;
            }

            if (patternType.GetDataTypeFamily() != DataTypeFamily.Character)
            {
                if (!SqlTypeConverter.CanChangeTypeImplicit(patternType, stringType))
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(like.FirstExpression, patternType, stringType));

                pattern = createExpression ? SqlTypeConverter.Convert(pattern, patternType, stringType) : null;
                patternType = stringType;
            }

            if (escapeType != null && escapeType.GetDataTypeFamily() != DataTypeFamily.Character)
            {
                if (!SqlTypeConverter.CanChangeTypeImplicit(escapeType, stringType))
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(like.FirstExpression, escapeType, stringType));

                escape = createExpression ? SqlTypeConverter.Convert(escape, escapeType, stringType) : null;
                escapeType = stringType;
            }

            if (!SqlDataTypeReferenceWithCollation.TryConvertCollation((SqlDataTypeReference)valueType, (SqlDataTypeReference)patternType, like, "like", out var collation, out var collationLabel, out var collationError))
                throw new NotSupportedQueryFragmentException(collationError);

            AssertCollationSensitive(stringType);

            ((SqlDataTypeReferenceWithCollation)stringType).Collation = collation;
            ((SqlDataTypeReferenceWithCollation)stringType).CollationLabel = collationLabel;
            ((SqlDataTypeReferenceWithCollation)stringType).CollationConflictError = collationError;

            if (escapeType != null && !SqlDataTypeReferenceWithCollation.TryConvertCollation(stringType, (SqlDataTypeReference)escapeType, like, "like", out collation, out collationLabel, out collationError))
            {
                throw new NotSupportedQueryFragmentException(collationError);
            }
            else
            {
                ((SqlDataTypeReferenceWithCollation)stringType).Collation = collation;
                ((SqlDataTypeReferenceWithCollation)stringType).CollationLabel = collationLabel;
                ((SqlDataTypeReferenceWithCollation)stringType).CollationConflictError = collationError;

                AssertCollationSensitive(stringType);
            }

            if (escape == null && createExpression)
                escape = Expression.Constant(SqlString.Null);

            if (like.SecondExpression is StringLiteral patternLiteral && (like.EscapeExpression == null || like.EscapeExpression is StringLiteral))
            {
                // Do a one-off conversion to regex
                try
                {
                    var regex = LikeToRegex(SqlTypeConverter.ConvertCollation(patternLiteral.Value, collation), like.EscapeExpression == null ? SqlString.Null : ((StringLiteral)like.EscapeExpression).Value, false);
                    if (like.NotDefined)
                        cacheKey = $"{valueCacheKey} NOT REGEX {regex}";
                    else
                        cacheKey = $"{valueCacheKey} REGEX {regex}";
                    return createExpression ? Expr.Call(() => Like(Expr.Arg<SqlString>(), Expr.Arg<Regex>(), Expr.Arg<bool>()), value, Expression.Constant(regex), Expression.Constant(like.NotDefined)) : null;
                }
                catch (ArgumentException ex)
                {
                    throw new NotSupportedQueryFragmentException(ex.Message, like.SecondExpression);
                }
            }

            if (createExpression)
            {
                value = Expr.Call(() => SqlTypeConverter.ConvertCollation(Expr.Arg<SqlString>(), Expr.Arg<Collation>()), value, Expression.Constant(collation));
                pattern = Expr.Call(() => SqlTypeConverter.ConvertCollation(Expr.Arg<SqlString>(), Expr.Arg<Collation>()), pattern, Expression.Constant(collation));
            }

            if (like.NotDefined)
                cacheKey = $"{valueCacheKey} NOT LIKE {patternCacheKey}";
            else
                cacheKey = $"{valueCacheKey} LIKE {patternCacheKey}";

            if (escapeCacheKey != null)
                cacheKey += $" ESCAPE {escapeCacheKey}";

            return createExpression ? Expr.Call(() => Like(Expr.Arg<SqlString>(), Expr.Arg<SqlString>(), Expr.Arg<SqlString>(), Expr.Arg<bool>()), value, pattern, escape, Expression.Constant(like.NotDefined)) : null;
        }

        internal static Regex LikeToRegex(SqlString pattern, SqlString escape, bool patIndex)
        {
            var regexBuilder = new StringBuilder();
            var pat = pattern.Value;

            if (pattern.SqlCompareOptions.HasFlag(SqlCompareOptions.IgnoreNonSpace))
                pat = RemoveDiacritics(pat);

            var endWildcard = false;

            if (!patIndex)
            {
                regexBuilder.Append("^");
            }
            else
            {
                if (!pattern.Value.StartsWith("%"))
                    regexBuilder.Append("^");
                else
                    pat = pat.TrimStart('%');

                endWildcard = pat.EndsWith("%");

                if (endWildcard)
                    pat = pat.TrimEnd('%');
            }

            var escaped = false;
            var inRange = false;
            var escapeChar = escape.IsNull ? '\0' : escape.Value[0];

            foreach (var ch in pat)
            {
                if (escapeChar != '\0' && ch == escapeChar)
                {
                    escaped = true;
                    continue;
                }

                if (escaped)
                {
                    regexBuilder.Append(Regex.Escape(ch.ToString()));
                    escaped = false;
                    continue;
                }

                if (ch == '[' && !inRange)
                {
                    regexBuilder.Append("[");
                    inRange = true;
                    continue;
                }

                if (ch == ']' && inRange)
                {
                    regexBuilder.Append("]");
                    inRange = false;
                    continue;
                }

                if ((ch == '^' || ch == '-') && inRange)
                {
                    regexBuilder.Append(ch);
                    continue;
                }

                if (inRange)
                {
                    regexBuilder.Append(Regex.Escape(ch.ToString()));
                    continue;
                }

                if (ch == '%')
                {
                    regexBuilder.Append(".*");
                    continue;
                }

                if (ch == '_')
                {
                    regexBuilder.Append('.');
                    continue;
                }

                regexBuilder.Append(Regex.Escape(ch.ToString()));
            }

            if (escaped || inRange)
                throw new ArgumentException("Invalid LIKE pattern");

            if (!patIndex || !endWildcard)
                regexBuilder.Append("$");

            var regexOptions = RegexOptions.Multiline;

            if (pattern.SqlCompareOptions.HasFlag(SqlCompareOptions.IgnoreCase))
                regexOptions |= RegexOptions.IgnoreCase;

            return new Regex(regexBuilder.ToString(), regexOptions);
        }

        private static SqlBoolean Like(SqlString value, SqlString pattern, SqlString escape, bool not)
        {
            if (value.IsNull || pattern.IsNull)
                return false;

            // Convert the LIKE pattern to a regex
            var regex = LikeToRegex(pattern, escape, false);

            return Like(value, regex, not);
        }

        private static SqlBoolean Like(SqlString value, Regex pattern, bool not)
        {
            if (value.IsNull)
                return false;

            var text = value.Value;

            if (value.SqlCompareOptions.HasFlag(SqlCompareOptions.IgnoreNonSpace))
                text = RemoveDiacritics(text);

            var result = pattern.IsMatch(text);

            if (not)
                result = !result;

            return result;
        }

        /// <summary>
        /// Removes accents from a string, used for accent-insensitive collations
        /// </summary>
        /// <ref>https://stackoverflow.com/a/249126/269629</ref>
        /// <param name="text">The text to remove the accents from</param>
        /// <returns>A version of the <paramref name="text"/> with accents removed</returns>
        internal static string RemoveDiacritics(string text)
        {
            var normalizedString = text.Normalize(NormalizationForm.FormD);
            var stringBuilder = new StringBuilder(capacity: normalizedString.Length);

            for (int i = 0; i < normalizedString.Length; i++)
            {
                char c = normalizedString[i];
                var unicodeCategory = CharUnicodeInfo.GetUnicodeCategory(c);
                if (unicodeCategory != UnicodeCategory.NonSpacingMark)
                {
                    stringBuilder.Append(c);
                }
            }

            return stringBuilder
                .ToString()
                .Normalize(NormalizationForm.FormC);
        }

        private static Expression ToExpression(this SimpleCaseExpression simpleCase, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            // Convert all the different elements to expressions
            var value = simpleCase.InvokeSubExpression(x => x.InputExpression, x => x.InputExpression, context, contextParam, exprParam, createExpression, out var valueType, out var valueCacheKey);
            var whenClauses = simpleCase.WhenClauses.Select((_, index) =>
            {
                var whenExpr = simpleCase.InvokeSubExpression(x => x.WhenClauses[index].WhenExpression, (x, i) => x.WhenClauses[i].WhenExpression, index, context, contextParam, exprParam, createExpression, out var whenType, out var whenCacheKey);
                return new { Expression = whenExpr, Type = whenType, CacheKey = whenCacheKey };
            }).ToList();
            var caseTypes = new DataTypeReference[whenClauses.Count];
            var thenClauses = simpleCase.WhenClauses.Select((_, index) =>
            {
                var thenExpr = simpleCase.InvokeSubExpression(x => x.WhenClauses[index].ThenExpression, (x, i) => x.WhenClauses[i].ThenExpression, index, context, contextParam, exprParam, createExpression, out var thenType, out var thenCacheKey);
                return new { Expression = thenExpr, Type = thenType, CacheKey = thenCacheKey };
            }).ToList();
            DataTypeReference elseType = null;
            string elseCacheKey = null;
            var elseValue = simpleCase.ElseExpression == null ? null : simpleCase.InvokeSubExpression(x => x.ElseExpression, x => x.ElseExpression, context, contextParam, exprParam, createExpression, out elseType, out elseCacheKey);

            // First pass to determine final return type
            DataTypeReference type = null;

            for (var i = 0; i < simpleCase.WhenClauses.Count; i++)
            {
                var whenType = whenClauses[i].Type;

                if (!SqlTypeConverter.CanMakeConsistentTypes(valueType, whenType, context.PrimaryDataSource, simpleCase, "case", out var caseType))
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(simpleCase.WhenClauses[i].WhenExpression, valueType, whenType));

                caseTypes[i] = caseType;

                var thenType = thenClauses[i].Type;

                if (type == null)
                    type = thenType;
                else if (!SqlTypeConverter.CanMakeConsistentTypes(type, thenType, context.PrimaryDataSource, simpleCase, "case", out type))
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(simpleCase, type, thenType));
            }

            if (elseValue != null)
            {
                if (type == null)
                    type = elseType;
                else if (!SqlTypeConverter.CanMakeConsistentTypes(type, elseType, context.PrimaryDataSource, simpleCase, "case", out type))
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(simpleCase, type, elseType));
            }

            // Second pass to build up the calculation. Do this in reverse so we can keep wrapping the previous expression in more conditions to
            // add the earlier cases
            Expression result = null;

            if (createExpression)
            {
                if (elseValue != null)
                {
                    if (!elseType.IsSameAs(type))
                        elseValue = SqlTypeConverter.Convert(elseValue, elseType, type);

                    result = elseValue;
                }
                else
                {
                    result = Expression.Constant(SqlTypeConverter.GetNullValue(type.ToNetType(out _)));
                }

                for (var i = simpleCase.WhenClauses.Count - 1; i >= 0; i--)
                {
                    var valueCopy = value;
                    var whenValue = whenClauses[i].Expression;
                    var whenType = whenClauses[i].Type;
                    var caseType = caseTypes[i];

                    if (!valueType.IsSameAs(caseType))
                        valueCopy = SqlTypeConverter.Convert(valueCopy, valueType, caseType);

                    if (!whenType.IsSameAs(caseType))
                        whenValue = SqlTypeConverter.Convert(whenValue, whenType, caseType);

                    var comparison = Expression.Equal(valueCopy, whenValue);
                    var returnValue = thenClauses[i].Expression;
                    var returnType = thenClauses[i].Type;

                    if (!returnType.IsSameAs(type))
                        returnValue = SqlTypeConverter.Convert(returnValue, returnType, type);

                    result = Expression.Condition(Expression.IsTrue(comparison), returnValue, result);
                }
            }

            cacheKey = "CASE " + valueCacheKey;
            for (var i = 0; i < whenClauses.Count; i++)
                cacheKey += " WHEN " + whenClauses[i].CacheKey + " THEN " + thenClauses[i].CacheKey;
            if (elseCacheKey != null)
                cacheKey += " ELSE " + elseCacheKey;
            cacheKey += " END";

            sqlType = type;
            return result;
        }

        private static Expression ToExpression(this SearchedCaseExpression searchedCase, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            // Convert all the different elements to expressions
            var whenClauses = searchedCase.WhenClauses.Select((_, index) =>
            {
                var whenExpr = searchedCase.InvokeSubExpression(x => x.WhenClauses[index].WhenExpression, (x, i) => x.WhenClauses[i].WhenExpression, index, context, contextParam, exprParam, createExpression, out var whenType, out var whenCacheKey);
                return new { Expression = whenExpr, Type = whenType, CacheKey = whenCacheKey };
            }).ToList();
            var thenClauses = searchedCase.WhenClauses.Select((_, index) =>
            {
                var thenExpr = searchedCase.InvokeSubExpression(x => x.WhenClauses[index].ThenExpression, (x, i) => x.WhenClauses[i].ThenExpression, index, context, contextParam, exprParam, createExpression, out var thenType, out var thenCacheKey );
                return new { Expression = thenExpr, Type = thenType, CacheKey = thenCacheKey };
            }).ToList();
            DataTypeReference elseType = null;
            string elseCacheKey = null;
            var elseValue = searchedCase.ElseExpression == null ? null : searchedCase.InvokeSubExpression(x => x.ElseExpression, x => x.ElseExpression, context, contextParam, exprParam, createExpression, out elseType, out elseCacheKey);

            // First pass to determine final return type
            DataTypeReference type = null;

            for (var i = 0; i < thenClauses.Count; i++)
            {
                var thenType = thenClauses[i].Type;

                if (type == null)
                    type = thenType;
                else if (!SqlTypeConverter.CanMakeConsistentTypes(type, thenType, context.PrimaryDataSource, searchedCase, "case", out type))
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(searchedCase, type, thenType));
            }

            if (elseValue != null)
            {
                if (type == null)
                    type = elseType;
                else if (!SqlTypeConverter.CanMakeConsistentTypes(type, elseType, context.PrimaryDataSource, searchedCase, "case", out type))
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(searchedCase, type, elseType));
            }

            // Second pass to build up the calculation. Do this in reverse so we can keep wrapping the previous expression in more conditions to
            // add the earlier cases
            Expression result = null;

            if (createExpression)
            {
                if (elseValue != null)
                {
                    if (!elseType.IsSameAs(type))
                        elseValue = SqlTypeConverter.Convert(elseValue, elseType, type);

                    result = elseValue;
                }
                else
                {
                    result = Expression.Constant(SqlTypeConverter.GetNullValue(type.ToNetType(out _)));
                }

                var bitType = DataTypeHelpers.Bit;

                for (var i = whenClauses.Count - 1; i >= 0; i--)
                {
                    var whenValue = whenClauses[i].Expression;
                    var whenType = whenClauses[i].Type;
                    var returnValue = thenClauses[i].Expression;
                    var returnType = thenClauses[i].Type;

                    whenValue = SqlTypeConverter.Convert(whenValue, whenType, bitType);
                    whenValue = Expression.IsTrue(whenValue);

                    returnValue = SqlTypeConverter.Convert(returnValue, returnType, type);

                    result = Expression.Condition(whenValue, returnValue, result);
                }
            }

            cacheKey = "CASE";
            for (var i = 0; i < whenClauses.Count; i++)
                cacheKey += " WHEN " + whenClauses[i].CacheKey + " THEN " + thenClauses[i].CacheKey;
            if (elseCacheKey != null)
                cacheKey += " ELSE " + elseCacheKey;
            cacheKey += " END";

            sqlType = type;
            return result;
        }

        private static Expression ToExpression(this BooleanNotExpression not, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            var value = not.InvokeSubExpression(x => x.Expression, x => x.Expression, context, contextParam, exprParam, createExpression, out sqlType, out cacheKey);
            cacheKey = "NOT " + cacheKey;
            return createExpression ? Expression.Not(value) : null;
        }

        private static readonly Dictionary<SqlDataTypeOption, Type> _typeMapping = new Dictionary<SqlDataTypeOption, Type>
        {
            [SqlDataTypeOption.BigInt] = typeof(SqlInt64),
            [SqlDataTypeOption.Binary] = typeof(SqlBinary),
            [SqlDataTypeOption.Bit] = typeof(SqlBoolean),
            [SqlDataTypeOption.Char] = typeof(SqlString),
            [SqlDataTypeOption.Date] = typeof(SqlDate),
            [SqlDataTypeOption.DateTime] = typeof(SqlDateTime),
            [SqlDataTypeOption.DateTime2] = typeof(SqlDateTime2),
            [SqlDataTypeOption.DateTimeOffset] = typeof(SqlDateTimeOffset),
            [SqlDataTypeOption.Decimal] = typeof(SqlDecimal),
            [SqlDataTypeOption.Float] = typeof(SqlDouble),
            [SqlDataTypeOption.Image] = typeof(SqlBinary),
            [SqlDataTypeOption.Int] = typeof(SqlInt32),
            [SqlDataTypeOption.Money] = typeof(SqlMoney),
            [SqlDataTypeOption.NChar] = typeof(SqlString),
            [SqlDataTypeOption.NText] = typeof(SqlString),
            [SqlDataTypeOption.Numeric] = typeof(SqlDecimal),
            [SqlDataTypeOption.NVarChar] = typeof(SqlString),
            [SqlDataTypeOption.Real] = typeof(SqlSingle),
            [SqlDataTypeOption.SmallDateTime] = typeof(SqlDateTime),
            [SqlDataTypeOption.SmallInt] = typeof(SqlInt16),
            [SqlDataTypeOption.SmallMoney] = typeof(SqlMoney),
            [SqlDataTypeOption.Text] = typeof(SqlString),
            [SqlDataTypeOption.Time] = typeof(SqlTime),
            [SqlDataTypeOption.TinyInt] = typeof(SqlByte),
            [SqlDataTypeOption.UniqueIdentifier] = typeof(SqlGuid),
            [SqlDataTypeOption.VarBinary] = typeof(SqlBinary),
            [SqlDataTypeOption.VarChar] = typeof(SqlString),
            [SqlDataTypeOption.Sql_Variant] = typeof(SqlVariant),
        };

        /// <summary>
        /// Converts a SQL <see cref="DataTypeReference"/> to the equivalent .NET <see cref="Type"/>
        /// </summary>
        /// <param name="type">The data type to convert</param>
        /// <param name="sqlDataType">If the <paramref name="type"/> is a <see cref="SqlDataTypeReference"/>, this is set to the cast value.</param>
        /// <returns>The equivalent .NET <see cref="Type"/></returns>
        public static Type ToNetType(this DataTypeReference type, out SqlDataTypeReference sqlDataType)
        {
            if (!(type is SqlDataTypeReference dataType))
            {
                if (type.IsSameAs(DataTypeHelpers.EntityReference))
                {
                    sqlDataType = null;
                    return typeof(SqlEntityReference);
                }

                if (type.IsSameAs(DataTypeHelpers.Xml))
                {
                    sqlDataType = null;
                    return typeof(SqlXml);
                }

                throw new NotSupportedQueryFragmentException(Sql4CdsError.InvalidDataType(type));
            }

            sqlDataType = dataType;

            if (!_typeMapping.TryGetValue(dataType.SqlDataTypeOption, out var targetType))
                throw new NotSupportedQueryFragmentException(Sql4CdsError.InvalidDataType(type));

            return targetType;
        }

        /// <summary>
        /// Checks if a data type is a specific SQL data type
        /// </summary>
        /// <param name="type">The data type to check</param>
        /// <param name="sqlType">The required SQL data type</param>
        /// <returns><c>true</c> if the <paramref name="type"/> is the expected <paramref name="sqlType"/>, or <c>false</c> otherwise</returns>
        public static bool IsType(this DataTypeReference type, SqlDataTypeOption sqlType)
        {
            if (!(type is SqlDataTypeReference sql))
                return false;

            return sql.SqlDataTypeOption == sqlType;
        }

        private static readonly Dictionary<Type, DataTypeReference> _netTypeMapping = new Dictionary<Type, DataTypeReference>
        {
            [typeof(SqlInt64)] = DataTypeHelpers.BigInt,
            [typeof(SqlBinary)] = DataTypeHelpers.VarBinary(Int32.MaxValue),
            [typeof(SqlBoolean)] = DataTypeHelpers.Bit,
            [typeof(SqlDateTime)] = DataTypeHelpers.DateTime,
            [typeof(SqlDecimal)] = DataTypeHelpers.Decimal(38, 10),
            [typeof(SqlDouble)] = DataTypeHelpers.Float,
            [typeof(SqlInt32)] = DataTypeHelpers.Int,
            [typeof(SqlMoney)] = DataTypeHelpers.Money,
            [typeof(SqlSingle)] = DataTypeHelpers.Real,
            [typeof(SqlInt16)] = DataTypeHelpers.SmallInt,
            [typeof(SqlByte)] = DataTypeHelpers.TinyInt,
            [typeof(SqlGuid)] = DataTypeHelpers.UniqueIdentifier,
            [typeof(SqlEntityReference)] = DataTypeHelpers.EntityReference,
            [typeof(SqlDateTime2)] = DataTypeHelpers.DateTime2(7),
            [typeof(SqlDateTimeOffset)] = DataTypeHelpers.DateTimeOffset,
            [typeof(SqlDate)] = DataTypeHelpers.Date,
            [typeof(SqlTime)] = DataTypeHelpers.Time(7),
            [typeof(SqlXml)] = DataTypeHelpers.Xml,
            [typeof(SqlVariant)] = DataTypeHelpers.Variant,
        };

        /// <summary>
        /// Converts a .NET <see cref="Type"/> to the equivalent SQL <see cref="DataTypeReference"/>
        /// </summary>
        /// <param name="type">The data type to convert</param>
        /// <returns>The equivalent SQL <see cref="DataTypeReference"/></returns>
        public static DataTypeReference ToSqlType(this Type type, DataSource dataSource)
        {
            if (type == typeof(SqlString))
                return DataTypeHelpers.NVarChar(Int32.MaxValue, dataSource?.DefaultCollation ?? Collation.USEnglish, dataSource?.DefaultCollation != null ? CollationLabel.Implicit : CollationLabel.CoercibleDefault);

            return _netTypeMapping[type];
        }

        private static Expression ToExpression(this ConvertCall convert, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            var value = convert.InvokeSubExpression(x => x.Parameter, x => x.Parameter, context, contextParam, exprParam, createExpression, out var valueType, out var valueCacheKey);
            DataTypeReference styleType = null;
            string styleCacheKey = null;
            var style = convert.Style == null ? null : convert.InvokeSubExpression(x => x.Style, x => x.Style, context, contextParam, exprParam, createExpression, out styleType, out styleCacheKey);

            sqlType = convert.DataType;

            return Convert(context, value, valueType, valueCacheKey, sqlType, style, styleType, styleCacheKey, convert, out cacheKey);
        }

        private static Expression Convert(ExpressionCompilationContext context, Expression value, DataTypeReference valueType, string valueCacheKey, DataTypeReference sqlType, Expression style, DataTypeReference styleType, string styleCacheKey, TSqlFragment expr, out string cacheKey)
        {
            if (sqlType is SqlDataTypeReference sqlTargetType &&
                sqlTargetType.SqlDataTypeOption.IsStringType())
            {
                // Set default length to 30
                if (sqlTargetType.Parameters.Count == 0)
                    sqlTargetType.Parameters.Add(new IntegerLiteral { Value = "30" });

                // If the input is a character string, the output string has the collation label of the input string
                // If the input is not a character string, the output string is coercible-default and assigned the collation of the current database for the connection
                var valueTypeColl = valueType as SqlDataTypeReferenceWithCollation;
                var collation = valueTypeColl?.Collation ?? context.PrimaryDataSource.DefaultCollation;
                var collationLabel = valueTypeColl?.CollationLabel ?? CollationLabel.CoercibleDefault;

                sqlType = new SqlDataTypeReferenceWithCollation
                {
                    SqlDataTypeOption = sqlTargetType.SqlDataTypeOption,
                    Parameters = { sqlTargetType.Parameters[0] },
                    Collation = collation,
                    CollationLabel = collationLabel
                };
            }

            cacheKey = $"CONVERT({sqlType.ToSql()}, {valueCacheKey}";
            if (styleCacheKey != null)
                cacheKey += ", " + styleCacheKey;
            cacheKey += ")";

            return value == null ? null : SqlTypeConverter.Convert(value, valueType, sqlType, style, styleType, expr);
        }

        private static Expression ToExpression(this CastCall cast, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            var value = cast.InvokeSubExpression(x => x.Parameter, x => x.Parameter, context, contextParam, exprParam, createExpression, out var valueType, out var valueCacheKey);
            sqlType = cast.DataType;

            return Convert(context, value, valueType, valueCacheKey, sqlType, null, null, null, cast, out cacheKey);
        }

        private static readonly Regex _containsParser = new Regex("^\\S+( OR \\S+)*$", RegexOptions.IgnoreCase | RegexOptions.Compiled);

        private static Expression ToExpression(this FullTextPredicate fullText, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            // Only support simple CONTAINS calls to handle multi-select optionsets for now
            if (fullText.FullTextFunctionType != FullTextFunctionType.Contains)
                throw new NotSupportedQueryFragmentException(Sql4CdsError.NotSupported(fullText, fullText.FullTextFunctionType.ToString())) { Suggestion = "Only CONTAINS is currently supported for full text searching" };

            if (fullText.Columns.Count != 1)
                throw new NotSupportedQueryFragmentException(Sql4CdsError.NotSupported(fullText, "multi-column CONTAINS"));

            if (fullText.Columns[0].ColumnType == ColumnType.Wildcard)
                throw new NotSupportedQueryFragmentException(Sql4CdsError.NotSupported(fullText, "multi-column CONTAINS"));

            if (fullText.PropertyName != null)
                throw new NotSupportedQueryFragmentException(Sql4CdsError.NotSupported(fullText.PropertyName, "PROPERTY"));

            if (fullText.LanguageTerm != null)
                throw new NotSupportedQueryFragmentException(Sql4CdsError.NotSupported(fullText.LanguageTerm, "LANGUAGE"));

            var col = fullText.InvokeSubExpression(x => x.Columns[0], (x, i) => x.Columns[i], 0, context, contextParam, exprParam, createExpression, out var colType, out var colCacheKey);
            var stringType = DataTypeHelpers.NVarChar(Int32.MaxValue, context.PrimaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault);

            if (!SqlTypeConverter.CanChangeTypeImplicit(colType, stringType))
                throw new NotSupportedQueryFragmentException(Sql4CdsError.InvalidColumnForFullTextSearch(fullText.Columns[0]));

            col = createExpression ? SqlTypeConverter.Convert(col, colType, stringType) : null;
            sqlType = DataTypeHelpers.Bit;

            if (fullText.Value is StringLiteral lit)
            {
                if (!_containsParser.IsMatch(lit.Value))
                    throw new NotSupportedQueryFragmentException(Sql4CdsError.NotSupported(lit, "complex CONTAINS patterns")) { Suggestion = "Only simple \"word OR word OR word\" patterns are currently supported" };

                var words = GetContainsWords(lit.Value, true);
                cacheKey = $"{colCacheKey} REGEX CONTAINS ({String.Join(", ", words.Select(w => w.ToString()))})";
                return createExpression ? Expr.Call(() => Contains(Expr.Arg<SqlString>(), Expr.Arg<Regex[]>()), col, Expression.Constant(words)) : null;
            }

            var value = fullText.InvokeSubExpression(x => x.Value, x => x.Value, context, contextParam, exprParam, createExpression, out var valueType, out var valueCacheKey);

            if (!SqlTypeConverter.CanChangeTypeImplicit(valueType, stringType))
                throw new NotSupportedQueryFragmentException(Sql4CdsError.TypeClash(fullText.Value, valueType, stringType));

            value = createExpression ? SqlTypeConverter.Convert(value, valueType, stringType) : null;

            cacheKey = $"{colCacheKey} CONTAINS {valueCacheKey}";
            return createExpression ? Expr.Call(() => Contains(Expr.Arg<SqlString>(), Expr.Arg<SqlString>()), col, value) : null;
        }

        private static SqlBoolean Contains(SqlString col, SqlString value)
        {
            if (col.IsNull || value.IsNull)
                return false;

            var words = GetContainsWords(value.Value, false);
            return Contains(col, words);
        }

        private static SqlBoolean Contains(SqlString col, Regex[] words)
        {
            if (col.IsNull)
                return false;

            return words.Any(w => w.IsMatch(col.Value));
        }

        private static Regex[] GetContainsWords(string pattern, bool compile)
        {
            if (!_containsParser.IsMatch(pattern))
                throw new QueryExecutionException(Sql4CdsError.InvalidFullTextPattern(pattern));

            var options = RegexOptions.IgnoreCase;
            if (compile)
                options |= RegexOptions.Compiled;

            var words = pattern.ToUpperInvariant().Split(new[] { " OR " }, StringSplitOptions.None);

            return words
                .Select(w => new Regex($@"\b{Regex.Escape(w)}\b", options))
                .ToArray();
        }

        private static Expression ToExpression(this ParameterlessCall parameterless, ExpressionCompilationContext context, ParameterExpression contextParam, ParameterExpression exprParam, bool createExpression, out DataTypeReference sqlType, out string cacheKey)
        {
            switch (parameterless.ParameterlessCallType)
            {
                case ParameterlessCallType.CurrentTimestamp:
                    sqlType = DataTypeHelpers.DateTime;
                    cacheKey = "CURRENT_TIMESTAMP";
                    return createExpression ? Expr.Call(() => GetCurrentTimestamp(Expr.Arg<ExpressionExecutionContext>()), contextParam) : null;

                default:
                    sqlType = DataTypeHelpers.EntityReference;
                    cacheKey = "CURRENT_USER";
                    return createExpression ? Expr.Call(() => GetCurrentUser(Expr.Arg<ExpressionExecutionContext>()), contextParam) : null;
            }
        }

        private static SqlDateTime GetCurrentTimestamp(ExpressionExecutionContext context)
        {
            if (context.Options.UseLocalTimeZone)
                return new SqlDateTime(DateTime.Now);
            else
                return new SqlDateTime(DateTime.UtcNow);
        }

        private static SqlEntityReference GetCurrentUser(ExpressionExecutionContext context)
        {
            return new SqlEntityReference(context.Options.PrimaryDataSource, "systemuser", context.Options.UserId);
        }

        /// <summary>
        /// Removes a condition from a boolean expression
        /// </summary>
        /// <param name="expr">The full boolean expression</param>
        /// <param name="remove">The condition to remove</param>
        /// <returns>A version of the <paramref name="expr"/> with the expression removed</returns>
        public static BooleanExpression RemoveCondition(this BooleanExpression expr, BooleanExpression remove)
        {
            if (expr == remove)
                return null;

            if (expr is BooleanBinaryExpression binary)
            {
                if (binary.FirstExpression == remove)
                    return binary.SecondExpression;

                if (binary.SecondExpression == remove)
                    return binary.FirstExpression;

                var clone = new BooleanBinaryExpression
                {
                    BinaryExpressionType = binary.BinaryExpressionType,
                    FirstExpression = binary.FirstExpression.RemoveCondition(remove),
                    SecondExpression = binary.SecondExpression.RemoveCondition(remove)
                };

                return clone;
            }

            if (expr is BooleanParenthesisExpression paren)
            {
                if (paren.Expression == remove)
                    return null;

                return new BooleanParenthesisExpression { Expression = paren.Expression.RemoveCondition(remove) };
            }

            return expr;
        }

        /// <summary>
        /// Gets the name of a column
        /// </summary>
        /// <param name="col">A <see cref="ColumnReferenceExpression"/></param>
        /// <returns>The name of the column being referenced</returns>
        public static string GetColumnName(this ColumnReferenceExpression col)
        {
            return String.Join(".", col.MultiPartIdentifier.Identifiers.Select(id => id.Value.EscapeIdentifier()));
        }

        /// <summary>
        /// Escapes an identifier if necessary
        /// </summary>
        /// <param name="identifier">The unescaped identifier</param>
        /// <returns>An</returns>
        public static string EscapeIdentifier(this string identifier)
        {
            if (IsValidIdentifier(identifier))
                return identifier;

            return Identifier.EncodeIdentifier(identifier);
        }

        /// <summary>
        /// Checks if an identifier is valid without escaping
        /// </summary>
        /// <param name="identifier">The unescaped identifier</param>
        /// <returns><c>true</c> if the identifier meets the rules of regular identifiers, or <c>false</c> otherwise</returns>
        /// <remarks>
        /// https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-identifiers?view=sql-server-ver16&redirectedfrom=MSDN#rules-for-regular-identifiers
        /// </remarks>
        public static bool IsValidIdentifier(this string identifier)
        {
            if (String.IsNullOrEmpty(identifier))
                return false;

            return _parser.ValidateIdentifier(identifier);
        }

        /// <summary>
        /// Gets a list of columns referenced in an expression
        /// </summary>
        /// <param name="fragment">The expression to get the list of columns from</param>
        /// <returns>A list of column names referenced in the <paramref name="fragment"/></returns>
        public static IEnumerable<string> GetColumns(this TSqlFragment fragment)
        {
            var visitor = new ColumnCollectingVisitor();
            fragment.Accept(visitor);

            return visitor.Columns
                .Where(col => col.ColumnType == ColumnType.Regular)
                .Select(col => col.GetColumnName())
                .Distinct();
        }

        /// <summary>
        /// Gets a list of variables referenced in an expression
        /// </summary>
        /// <param name="fragment">The expression to get the list of variables from</param>
        /// <returns>A list of variable names referenced in the <paramref name="fragment"/></returns>
        public static IEnumerable<string> GetVariables(this TSqlFragment fragment)
        {
            var visitor = new VariableCollectingVisitor();
            fragment.Accept(visitor);

            return visitor.Variables
                .Select(var => var.Name)
                .Distinct();
        }

        /// <summary>
        /// Parses a column name into a <see cref="ColumnReferenceExpression"/>
        /// </summary>
        /// <param name="colName">The column name to parse</param>
        /// <returns>An equivalent <see cref="ColumnReferenceExpression"/></returns>
        public static ColumnReferenceExpression ToColumnReference(this string colName)
        {
            var col = new ColumnReferenceExpression { MultiPartIdentifier = new MultiPartIdentifier() };

            foreach (var part in colName.SplitMultiPartIdentifier())
            {
                var identifier = new Identifier { Value = part };

                if (!IsValidIdentifier(part))
                    identifier.QuoteType = QuoteType.SquareBracket;

                col.MultiPartIdentifier.Identifiers.Add(identifier);
            }

            return col;
        }

        /// <summary>
        /// Splits a multi-part identifier into its constituent parts
        /// </summary>
        /// <param name="colName">The multi-part identifier to split</param>
        /// <returns></returns>
        /// <exception cref="FormatException"></exception>
        public static string[] SplitMultiPartIdentifier(this string colName)
        {
            var parts = new List<string>();

            var i = 0;
            while (i < colName.Length)
            {
                if (colName[i] == '[' || colName[i] == '"')
                {
                    // Escaped identifier
                    var escape = colName[i] == '[' ? ']' : '"';
                    i++;

                    int end;
                    do
                    {
                        end = colName.IndexOf(escape, i);
                    } while (end < colName.Length - 1 && colName[end + 1] == escape);

                    parts.Add(colName.Substring(i, end - i));

                    i = end + 1;
                }
                else
                {
                    var end = colName.IndexOf('.', i);

                    if (end == -1)
                        end = colName.Length;

                    parts.Add(colName.Substring(i, end - i));

                    i = end;
                }

                if (i < colName.Length)
                {
                    if (colName[i] != '.')
                        throw new FormatException();

                    i++;
                }
            }

            return parts.ToArray();
        }

        /// <summary>
        /// Checks if an expression has a constant value
        /// </summary>
        /// <param name="expr">The expression to check</param>
        /// <param name="context">The context the expression is being evaluated in</param>
        /// <param name="literal">The equivalent literal value</param>
        /// <returns><c>true</c> if the expression has a constant value, or <c>false</c> if it can change depending on the current data record</returns>
        public static bool IsConstantValueExpression(this ScalarExpression expr, ExpressionCompilationContext context, out Literal literal)
        {
            literal = expr as Literal;

            if (literal != null)
                return true;

            var columnVisitor = new ColumnCollectingVisitor();
            expr.Accept(columnVisitor);

            if (columnVisitor.Columns.Count > 0)
                return false;

            var variableVisitor = new VariableCollectingVisitor();
            expr.Accept(variableVisitor);

            if (variableVisitor.Variables.Count > 0 || variableVisitor.GlobalVariables.Count > 0)
                return false;

            var parameterlessVisitor = new ParameterlessCollectingVisitor();
            expr.Accept(parameterlessVisitor);

            if (parameterlessVisitor.ParameterlessCalls.Any(p => p.ParameterlessCallType != ParameterlessCallType.CurrentTimestamp))
                return false;

            var evaluationContext = new ExpressionExecutionContext(context);
            var value = expr.Compile(context)(evaluationContext);

            if (value == null || value is INullable n && n.IsNull)
                literal = new NullLiteral();
            else if (value is SqlInt32 i)
                literal = new IntegerLiteral { Value = i.ToString() };
            else if (value is SqlDecimal dec)
                literal = new NumericLiteral { Value = dec.ToString() };
            else if (value is SqlDouble dbl)
                literal = new NumericLiteral { Value = dbl.ToString() };
            else if (value is SqlSingle flt)
                literal = new RealLiteral { Value = flt.ToString() };
            else if (value is SqlString str)
                literal = new StringLiteral { Value = str.ToString() };
            else if (value is SqlDateTime dt)
                literal = new StringLiteral { Value = dt.Value.ToString("yyyy-MM-ddTHH:mm:ss.fff") };
            else if (value is SqlGuid g)
                literal = new StringLiteral { Value = g.ToString() };
            else
                return false;

            return true;
        }

        private static void AssertCollationSensitive(DataTypeReference finalType)
        {
            if (finalType is SqlDataTypeReferenceWithCollation collation &&
                collation.CollationLabel == CollationLabel.NoCollation)
                throw new NotSupportedQueryFragmentException(collation.CollationConflictError);
        }

        /// <summary>
        /// Combines two boolean expressions with AND
        /// </summary>
        /// <param name="expr1">The first expression</param>
        /// <param name="expr2">The second expression</param>
        /// <returns>The two expressions combined with AND</returns>
        public static BooleanExpression And(this BooleanExpression expr1, BooleanExpression expr2)
        {
            if (expr1 == null)
                return expr2;

            if (expr2 == null)
                return expr1;

            return new BooleanBinaryExpression
            {
                FirstExpression = expr1,
                BinaryExpressionType = BooleanBinaryExpressionType.And,
                SecondExpression = expr2
            };
        }

        /// <summary>
        /// Returns the comparison type that can be used for the transitive comparison
        /// </summary>
        /// <param name="cmp">The comparison type to get the transitive version of</param>
        /// <returns>The transitive comparison type</returns>
        public static BooleanComparisonType TransitiveComparison(this BooleanComparisonType cmp)
        {
            switch (cmp)
            {
                case BooleanComparisonType.Equals:
                case BooleanComparisonType.NotEqualToBrackets:
                case BooleanComparisonType.NotEqualToExclamation:
                case BooleanComparisonType.IsDistinctFrom:
                case BooleanComparisonType.IsNotDistinctFrom:
                    return cmp;

                case BooleanComparisonType.LessThan:
                    return BooleanComparisonType.GreaterThanOrEqualTo;

                case BooleanComparisonType.LessThanOrEqualTo:
                case BooleanComparisonType.NotGreaterThan:
                    return BooleanComparisonType.GreaterThan;

                case BooleanComparisonType.GreaterThan:
                    return BooleanComparisonType.LessThanOrEqualTo;

                case BooleanComparisonType.GreaterThanOrEqualTo:
                case BooleanComparisonType.NotLessThan:
                    return BooleanComparisonType.LessThan;

                default:
                    throw new ArgumentOutOfRangeException(nameof(cmp));
            }
        }
    }
}
